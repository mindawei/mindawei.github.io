<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天未的博客</title>
  
  <subtitle>天未欲使从是也，吾辈必济。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mindawei.github.io/"/>
  <updated>2018-05-06T13:09:10.000Z</updated>
  <id>http://mindawei.github.io/</id>
  
  <author>
    <name>天未</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多机使用Hexo博客</title>
    <link href="http://mindawei.github.io/2018/05/01/%E5%A4%9A%E6%9C%BA%E4%BD%BF%E7%94%A8Hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://mindawei.github.io/2018/05/01/多机使用Hexo博客/</id>
    <published>2018-05-01T14:14:05.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下 hexo 博客迁移到另一台电脑上的操作。</p><a id="more"></a><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>之前博客使用 Hexo ，本地写完后，使用 <code>hexo g -d</code> 命令后，就直接在 public 生成站点，将网站内容部署到 github 上，但是原始文件没有上传，这样无法再多台机器上一起使用该博客。</p><h1 id="解决参考"><a href="#解决参考" class="headerlink" title="解决参考"></a>解决参考</h1><p>参考 <a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">《使用hexo，如果换了电脑怎么更新博客？》</a>。</p><p>解决思路如下：</p><ol><li>使用 master 和 hexo 两个分支。</li><li>master 分支用来保存生成的网站内容。</li><li>hexo 分支保存原始的代码。</li></ol><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><ol><li>创建新分支 hexo，可参考 <a href="https://blog.csdn.net/xlyrh/article/details/70940753" target="_blank" rel="noopener">《创建Git新分支步骤》</a>。</li><li>将 hexo 博客的源文件提交到新分支 hexo 上。</li><li>然后在 github 上项目上设置默认的分支为你新建的分支（这里新分支为 hexo）。</li><li>然后在新的电脑上拷贝这个项目的代码（拷贝默认的 hexo 分支）。</li><li>在 hexo 分支上开发，然后提交代码到默认的 hexo 分支：<code>git add .</code>、<code>git commit -m &quot;...&quot;</code>、<code>git push origin hexo</code>。</li><li>修改 <code>_config.yml</code> 中的 deploy 参数，分支应为 master。</li><li>使用 <code>hexo g -d</code> 将网站更新到 master 分支上。</li></ol><h1 id="Next-主题缺失问题"><a href="#Next-主题缺失问题" class="headerlink" title="Next 主题缺失问题"></a>Next 主题缺失问题</h1><p>按上面操作后，会发现 hexo 博客还是跑不起来，网上查找原因后发现 next 主题文件夹为空。如下：</p><p><a href="https://www.zhihu.com/question/38781463?sort=created" target="_blank" rel="noopener">《hexo本地测试运行重启后页面空白,提示 : WARN No layout: index.html?》</a></p><p>这个问题的解决一下子找不到了。。。基本思路是，拉一个 next 的主题下来，然后使用子模块的设置 submodule，将 next 主题独立到一个仓库中。</p><p>由于本质上是利用 github 来做一个云端的存储，所以我直接新建了一个项目，把这个 next 主题传了上去，如果有更改，就进行更新，其实是差不多的。用的时候，直接拷贝下来放入 next 文件夹中即可。</p><p>可能之前尝试使用子模块的操作，启动 hexo 报了这个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule: already exists in the index</span><br></pre></td></tr></table></figure></p><p>这个解决可以参考：<br><a href="https://my.oschina.net/jerikc/blog/513039" target="_blank" rel="noopener">《git submodule: already exists in the index》</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下 hexo 博客迁移到另一台电脑上的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="环境" scheme="http://mindawei.github.io/categories/%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="hexo" scheme="http://mindawei.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Mac快捷键</title>
    <link href="http://mindawei.github.io/2018/05/01/Mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://mindawei.github.io/2018/05/01/Mac快捷键/</id>
    <published>2018-05-01T08:16:26.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对苹果电脑上的一些快捷键的记录。</p><a id="more"></a><p>按钮说明：</p><ul><li>command 简记为 cmd</li><li>delete 简记为 del</li><li>control 简记为 ctl</li><li>option 简记为 opt</li><li>空格 记为 space</li><li>关机键 记为 off</li></ul><h1 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h1><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>cmd + tab</td><td>在应用之间切换</td></tr><tr><td>cmd + shift + tab</td><td>在应用之间切换，反向</td></tr></tbody></table><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>cmd + N</td><td>新建</td></tr><tr><td>cmd + O</td><td>打开</td></tr><tr><td>cmd + S</td><td>保存</td></tr><tr><td>cmd + A</td><td>全选</td></tr><tr><td>cmd + shift + S</td><td>另存为</td></tr><tr><td>cmd + W</td><td>关闭</td></tr><tr><td>cmd + Q</td><td>退出</td></tr><tr><td>cmd + F</td><td>搜索</td></tr></tbody></table><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>cmd + shift + 3</td><td>截取整个屏幕</td></tr><tr><td>cmd + shift + 4</td><td>截取选择区域</td></tr><tr><td>cmd + shift + 4 + space</td><td>截取整个应用界面</td></tr></tbody></table><h2 id="文件管理器"><a href="#文件管理器" class="headerlink" title="文件管理器"></a>文件管理器</h2><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>space</td><td>快速查看文件</td></tr><tr><td>cmd + I</td><td>显示文件简介</td></tr><tr><td>cmd + C</td><td>复制</td></tr><tr><td>cmd + V</td><td>粘贴</td></tr><tr><td>cmd + del</td><td>删除</td></tr><tr><td>cmd + shift + del</td><td>清空回收站</td></tr></tbody></table><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>ctl + shift + off</td><td>关闭显示器</td></tr><tr><td>cmd + opt + off</td><td>睡眠</td></tr><tr><td>cmd + opt + esc</td><td>强制退出程序</td></tr><tr><td>cmd + ctl + off</td><td>重启</td></tr><tr><td>cmd + space</td><td>切换输入法</td></tr></tbody></table><h1 id="谷歌浏览器"><a href="#谷歌浏览器" class="headerlink" title="谷歌浏览器"></a>谷歌浏览器</h1><p><a href="https://blog.csdn.net/duanyipeng/article/details/8637391" target="_blank" rel="noopener">Chrome for Mac键盘快捷键！来自Google Chrome官网！</a></p><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>cmd + +</td><td>放大</td></tr><tr><td>cmd + -</td><td>缩小</td></tr><tr><td>cmd + T</td><td>新标签页</td></tr><tr><td>cmd + N</td><td>新窗口</td></tr><tr><td>cmd + R</td><td>刷新</td></tr><tr><td>cmd + W</td><td>关闭当前标签页</td></tr><tr><td>cmd + ～</td><td>切换应用窗口</td></tr><tr><td>cmd + shift + N</td><td>隐身打开新窗口</td></tr><tr><td>cmd + O</td><td>打开计算机中的文件</td></tr><tr><td>cmd + 链接</td><td>从新标签页中打开链接</td></tr><tr><td>shift + 链接</td><td>从新窗口中打开链接</td></tr><tr><td>cmd + opt + 左右箭头</td><td>切换标签页</td></tr><tr><td>cmd + shift + W</td><td>关闭当前窗口</td></tr><tr><td>cmd + shift + T</td><td>重新打开上次关闭的标签，最多记住10个</td></tr><tr><td>cmd + [</td><td>标签页的上一页历史</td></tr><tr><td>cmd + ]</td><td>标签页的下一页历史</td></tr><tr><td>cmd + M</td><td>最小化窗口</td></tr><tr><td>cmd + H</td><td>隐藏窗口</td></tr><tr><td>cmd + Q</td><td>关闭浏览器</td></tr><tr><td>cmd + ctl + F</td><td>最大化当前标签</td></tr><tr><td>cmd + shift + B</td><td>打开和关闭书签栏</td></tr><tr><td>cmd + opt + B</td><td>打开书签管理器</td></tr><tr><td>cmd + ,</td><td>打开偏好设置</td></tr><tr><td>cmd + Y</td><td>打开历史记录</td></tr><tr><td>cmd + shift + J</td><td>打开下载内容</td></tr><tr><td>cmd + shift + del</td><td>打开清楚浏览数据对话框</td></tr><tr><td>输入网址时 + tab</td><td>进行提示补全</td></tr><tr><td>cmd + L</td><td>选中网址</td></tr><tr><td>opt + 左右箭头</td><td>可以跳跃单词</td></tr><tr><td>opt + shift + 左右箭头</td><td>选中下一个单词</td></tr><tr><td>cmd + del</td><td>删除地址栏中光标前的关键字</td></tr><tr><td>cmd + opt + I</td><td>打开开发者工具</td></tr><tr><td>cmd + D</td><td>将当前网页保存为书签</td></tr><tr><td>cmd + shift + D</td><td>将所有打开的网页保存到书签</td></tr><tr><td>space</td><td>向下滚动网页</td></tr><tr><td>cmd + opt + F</td><td>使用谷歌搜索</td></tr></tbody></table><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p><a href="http://www.etwiki.cn/mac-os/bash-shell.html" target="_blank" rel="noopener">Mac Terminal 常用快捷键 Bash shell</a></p><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>ctl + A</td><td>跳到行首</td></tr><tr><td>ctl + E</td><td>跳到行尾</td></tr><tr><td>opt + 左右箭头</td><td>左右移动一个单词位</td></tr><tr><td>ctl + K</td><td>从光标处删除到行尾</td></tr><tr><td>ctl + U</td><td>从光标处删除到行首</td></tr><tr><td>ctl + W</td><td>从光标处删除到字首</td></tr><tr><td>ctl + Y</td><td>粘贴最后一次被删除的单词</td></tr><tr><td>ctl + R</td><td>逆向搜索命令历史</td></tr><tr><td>ctl + G</td><td>从历史搜索模式退出</td></tr><tr><td>ctl + P</td><td>历史中的上一条命令</td></tr><tr><td>ctl + N</td><td>历史中的下一条命令</td></tr></tbody></table><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p><a href="https://www.cnblogs.com/my--sunshine/p/7093412.html" target="_blank" rel="noopener">Git常用命令总结</a></p><table><thead><tr><th>按钮</th><th>功能</th></tr></thead><tbody><tr><td>git status</td><td>查询repo的状态</td></tr><tr><td>git status -s</td><td>输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言</td></tr><tr><td>git log</td><td>查看提交历史</td></tr><tr><td>git log –oneline</td><td>查看提交历史，每次提交显示一行</td></tr><tr><td>git log –oneline –graph</td><td>图形化地表示出分支合并历史</td></tr><tr><td>git log branchname</td><td>显示特定分支的log</td></tr><tr><td>git log –author=[author name]</td><td>查看作者的提交历史</td></tr><tr><td>git log –grep=keywords</td><td>根据commit信息过滤log</td></tr><tr><td>git log -p</td><td>把每次提交的diff计算出来,作为一个patch显示</td></tr><tr><td>git log –stat</td><td>把每次提交的diff计算出来,–stat比-p的输出更简单一些</td></tr><tr><td>git add</td><td>添加新的文件或改动到暂存区(staging area)</td></tr><tr><td>git add .</td><td>递归添加当前工作目录中所有文件</td></tr><tr><td>git diff</td><td>比较工作目录中当前文件和暂存区域快照之间的差异,即修改后还没暂存起来的内容</td></tr><tr><td>git diff –cached</td><td>查看已经暂存起来的文件和上次提交时的快照之间的差异</td></tr><tr><td>git diff –staged</td><td>效果同上，Git 1.6.1 及更高版本</td></tr><tr><td>git diff HEAD</td><td>比较工作目录和上次提交之间所有的改动</td></tr><tr><td>git diff –stat</td><td>diff也可以加上–stat参数来简化输出</td></tr><tr><td>git diff [branchA] [branchB]</td><td>可以用来比较两个分支，实际上会返回一个由A到B的patch</td></tr><tr><td>git diff [branchA]…[branchB]</td><td>看两个分支分开以后各自的改动都是什么，实际上是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果</td></tr><tr><td>git commit -m “commit message”</td><td>提交add的内容</td></tr><tr><td>git commit -a</td><td>会先把所有已经track的文件的改动add进来,然后提交，对于没有track的文件,还是需要git add一下</td></tr><tr><td>git commit –amend</td><td>增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消</td></tr><tr><td>git reset HEAD</td><td>把不小心add的文件从staged状态取出来</td></tr><tr><td>git reset HEAD filename</td><td>把不小心add的具体文件从staged状态取出来</td></tr><tr><td>git reset –mixed id</td><td>将git的HEAD变了(提交记录变了),但文件并没有改变(working tree并没有改变)，取消了commit和add的内容</td></tr><tr><td>git reset –soft id</td><td>是git reset –mixed id 后,又做了一次git add.即取消了commit的内容</td></tr><tr><td>git reset –hard id</td><td>是将git的HEAD变了,文件也变了</td></tr><tr><td>git revert HEAD</td><td>撤销最近的一个提交</td></tr><tr><td>git rm file</td><td>从staging区移除文件,同时也移除出工作目录</td></tr><tr><td>git rm –cached</td><td>从staging区移除文件,但留在工作目录中</td></tr><tr><td>git clean -df</td><td>从工作目录中移除没有track的文件，-d表示同时移除目录,-f表示force,因为在配置中, clean.requireForce=true,如果不加-f,clean将会拒绝执行</td></tr><tr><td>git branch (branchname)</td><td>创建一个新的分支，分支是基于你的上一次提交建立的</td></tr><tr><td>git branch -v</td><td>可以看见每一个分支的最后一次提交</td></tr><tr><td>git branch</td><td>列出本地所有分支,当前分支会被星号标示出</td></tr><tr><td>git branch -d</td><td>删除一个分支</td></tr><tr><td>git push (remote-name) :(branch-name)</td><td>删除远程的一个分支</td></tr><tr><td>git checkout -b (branchname)</td><td>创建并切换到新的分支</td></tr><tr><td>git checkout –<filename></filename></td><td>使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响</td></tr><tr><td>git merge [alias]/[branch]</td><td>把远程分支merge到当前分支</td></tr><tr><td>git tag</td><td>会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag</td></tr><tr><td>git tag -a v1.0</td><td>-a参数会允许你添加一些信息,即make an annotated tag</td></tr><tr><td>git remote</td><td>列出remote 别名</td></tr><tr><td>git remote -v</td><td>可以看见每个别名对应的实际url</td></tr><tr><td>git remote add [alias] [url]</td><td>添加一个新的remote repo</td></tr><tr><td>git remote rm [alias]</td><td>删除一个存在的remote alias</td></tr><tr><td>git remote rename [old-alias] [new-alias]</td><td>分支重新命名</td></tr><tr><td>git remote set-url [alias] [url]</td><td>跟新别名对应的地址</td></tr><tr><td>git fetch</td><td>获取新的分支和数据</td></tr><tr><td>git fetch [alias]</td><td>取某一个远程repo</td></tr><tr><td>git pull</td><td>首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支</td></tr><tr><td>git push [alias] [branch]</td><td>将会把当前分支merge到alias上的[branch]分支</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对苹果电脑上的一些快捷键的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="http://mindawei.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="快捷键" scheme="http://mindawei.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Redis 的安装和使用</title>
    <link href="http://mindawei.github.io/2018/05/01/Redis-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://mindawei.github.io/2018/05/01/Redis-的安装和使用/</id>
    <published>2018-05-01T06:41:47.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是安装和使用 Redis 时的一个简单记录，主要参考了 <a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis 教程</a>。<br><a id="more"></a></p><h1 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h1><p>参考 <a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">Redis 安装</a></p><p>mac 下安装也可以使用 homebrew，homebrew 是 mac 的包管理器。<br>1、执行 <code>brew install redis</code><br>2、启动 redis，可以使用后台服务启动 <code>brew services start redis</code>。或者直接启动：<code>redis-server /usr/local/etc/redis.conf</code>。</p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>参考 <a href="http://www.runoob.com/redis/redis-conf.html" target="_blank" rel="noopener">Redis 配置</a></p><p>打开配置文件 <code>/usr/local/etc/redis.conf</code> 进行配置。</p><p>requirepass  字段配置密码。</p><h1 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h1><h2 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h2><p>1.默认启动<br><code>redis-cli</code> 启动客户端，按照默认配置连接 Redis（127.0.0.1:6379）。</p><p>2.指定地址和端口号<br><code>redis-cli -h 127.0.0.1 -p 6379</code></p><h2 id="关闭服务端"><a href="#关闭服务端" class="headerlink" title="关闭服务端"></a>关闭服务端</h2><p>参考 <a href="https://www.cnblogs.com/shoren/p/redis.html" target="_blank" rel="noopener">mac下redis安装、设置、启动停止</a></p><p>1.强行关闭<br>强行终止redis进程可能会导致数据丢失，因为redis可能正在将内存数据同步到硬盘中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps axu|grep redis  ## 查找redis-server的PID</span><br><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure></p><p>2.命令关闭<br>向redis发送SHUTDOWN命令，即 <code>redis-cli SHUTDOWN</code>。Redis收到命令后，服务端会断开所有客户端的连接，然后根据配置执行持久化，最后退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 启动redis-server，后台线程</span><br><span class="line">AT8775:redis shoren$ redis-server /usr/local/etc/redis.conf </span><br><span class="line">12105:C 29 Apr 22:16:14.570 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">12105:C 29 Apr 22:16:14.571 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=12105, just started</span><br><span class="line">12105:C 29 Apr 22:16:14.571 # Configuration loaded</span><br><span class="line"></span><br><span class="line">## 启动成功</span><br><span class="line">AT8775:redis shoren$ ps axu|grep redis</span><br><span class="line">mindw            12108   0.0  0.0  2432804   1940 s002  S+   10:16下午   0:00.00 grep redis</span><br><span class="line">mindw            12106   0.0  0.0  2458976   2248   ??  Ss   10:16下午   0:00.02 redis-server 127.0.0.1:6379</span><br><span class="line"></span><br><span class="line">## 关闭服务器</span><br><span class="line">mindwdeMacBook-Pro:~ mindw$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; AUTH 你设置的密码</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">mindwdeMacBook-Pro:~ mindw$ ps axu|grep redis</span><br><span class="line">mindw            12122   0.0  0.0  2432804   1940 s002  S+   10:19下午   0:00.00 grep redis</span><br></pre></td></tr></table></figure><h2 id="客户端操作-Redis-服务器"><a href="#客户端操作-Redis-服务器" class="headerlink" title="客户端操作 Redis 服务器"></a>客户端操作 Redis 服务器</h2><p>参考 <a href="http://www.runoob.com/redis/redis-server.html" target="_blank" rel="noopener">Redis 服务器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是安装和使用 Redis 时的一个简单记录，主要参考了 &lt;a href=&quot;http://www.runoob.com/redis/redis-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis 教程&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://mindawei.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://mindawei.github.io/tags/Redis/"/>
    
      <category term="入门" scheme="http://mindawei.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Guava学习之ListenableFuture</title>
    <link href="http://mindawei.github.io/2018/03/20/Guava%E5%AD%A6%E4%B9%A0%E4%B9%8BListenableFuture/"/>
    <id>http://mindawei.github.io/2018/03/20/Guava学习之ListenableFuture/</id>
    <published>2018-03-20T14:24:31.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 Guava 中 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener">ListenableFuture</a> 的学习介绍。欢迎加入学习项目： <a href="https://github.com/JavaMilk/LearningGuava" target="_blank" rel="noopener">LearningGuava</a>。</p><a id="more"></a><p>以下参考: <a href="https://github.com/google/guava/wiki/ListenableFutureExplained" target="_blank" rel="noopener">官方文档</a></p><p>处理并发是一个很困难的问题，但是我们可以通过使用功能强大的抽象来简化这个工作。为了简化这个问题，Guava 提供了 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener">ListenableFuture</a>，它继承了 JDK 中的 <code>Future</code> 接口。 </p><p><strong>我们强烈建议：在你的代码中，使用 <code>ListenableFuture</code> 来替代 <code>Future</code></strong>，因为 </p><ul><li>很多 <code>Future</code> 相关的方法需要它。</li><li>一开始就使用 <code>ListenableFuture</code> 会省事很多。</li><li>这样工具方法提供者就不需要针对 <code>Future</code> 和 <code>ListenableFuture</code> 都提供方法。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><code>Future</code> 代表了异步执行的结果：一个可能还没有产生结果的执行过程。 <code>Future</code> 可以正在被执行，但是会保证返回一个结果。</p><p><code>ListenableFuture</code> 可以使你注册回调函数，使得在结果计算完成的时候可以回调你的函数。如果结果已经算好，那么将会立即回调。这个简单的功能使得可以完成很多 <code>Future</code> 支持不了的操作。</p><p><code>ListenableFuture</code> 添加的基本函数是 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html#addListener-java.lang.Runnable-java.util.concurrent.Executor-" target="_blank" rel="noopener"><code>addListener(Runnable, Executor)</code></a>。通过这个函数，当 <code>Future</code> 中的结果执行完成时，传入的 <code>Runnable</code> 会在传入的 <code>Executor</code> 中执行。</p><h1 id="添加回调函数"><a href="#添加回调函数" class="headerlink" title="添加回调函数"></a>添加回调函数</h1><p>使用者偏向于使用 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#addCallback-com.google.common.util.concurrent.ListenableFuture-com.google.common.util.concurrent.FutureCallback-java.util.concurrent.Executor-" target="_blank" rel="noopener"><code>Futures.addCallback(ListenableFuture&lt;V&gt;, FutureCallback&lt;V&gt;, Executor)</code></a> , 或者当需要注册轻量级的回调的时候，可以使用默认为 <code>MoreExecutors.directExecutor()</code> 的<a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#addCallback-com.google.common.util.concurrent.ListenableFuture-com.google.common.util.concurrent.FutureCallback-" target="_blank" rel="noopener">版本</a>。 </p><p><code>FutureCallback&lt;V&gt;</code> 实现了两个方法:</p><ul><li><a href=""><code>onSuccess(V)</code></a> ：当 future 执行成功时候的反应。</li><li><a href=""><code>onFailure(Throwable)</code></a>：当 future 执行失败时候的反应。</li></ul><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>与 JDK 中 通过 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html#submit-java.util.concurrent.Callable-" target="_blank" rel="noopener"><code>ExecutorService.submit(Callable)</code></a> 来初始化一个异步的任务相似，Guava 提供了一个 <code>ListeningExecutorService</code> 接口，这个接口可以返回一个 <code>ListenableFuture</code>（<code>ExecutorService</code> 只是返回一个普通的 <code>Future</code>）。如果需要将一个 <code>ExecutorService</code> 转换为 <code>ListeningExecutorService</code>，可以使用 <a href="https://github.com/google/guava/wiki/ListenableFutureExplained#listenablefuture" target="_blank" rel="noopener"><code>MoreExecutors.listeningDecorator(ExecutorService)</code></a>。一个使用示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));</span><br><span class="line">ListenableFuture&lt;Explosion&gt; explosion = service.submit(new Callable&lt;Explosion&gt;() &#123;</span><br><span class="line">  public Explosion call() &#123;</span><br><span class="line">    return pushBigRedButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Futures.addCallback(explosion, new FutureCallback&lt;Explosion&gt;() &#123;</span><br><span class="line">  // we want this handler to run immediately after we push the big red button!</span><br><span class="line">  public void onSuccess(Explosion explosion) &#123;</span><br><span class="line">    walkAwayFrom(explosion);</span><br><span class="line">  &#125;</span><br><span class="line">  public void onFailure(Throwable thrown) &#123;</span><br><span class="line">    battleArchNemesis(); // escaped the explosion!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果你想从一个基于 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html" target="_blank" rel="noopener"><code>FutureTask</code></a> 的 API 转换过来，Guava 提供了 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFutureTask.html#create-java.util.concurrent.Callable-" target="_blank" rel="noopener"><code>ListenableFutureTask.create(Callable&lt;V&gt;)</code></a> 和 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFutureTask.html#create-java.lang.Runnable-V-" target="_blank" rel="noopener"><code>ListenableFutureTask.create(Runnable, V)</code></a>。和 JDK 不一样，<code>ListenableFutureTask</code> 并不意味着可以直接扩展。</p><p>如果你更喜欢可以设置 future 值的抽象，而不是实现一个方法来计算结果，那么可以考虑直接扩展 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/AbstractFuture.html" target="_blank" rel="noopener"><code>AbstractFuture&lt;V&gt;</code></a> 或者 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/SettableFuture.html" target="_blank" rel="noopener"><code>SettableFuture</code></a>。</p><p>如果你一定要将一个基于 <code>Future</code> 的 API 转换为基于 <code>ListenableFuture</code> 的话，你不得不采用硬编码的方式 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/JdkFutureAdapters.html" target="_blank" rel="noopener"><code>JdkFutureAdapters.listenInPoolThread(Future)</code></a> 来实现从 <code>Future</code> 到 <code>ListenableFuture</code> 的转换。所以，尽可能地使用 <code>ListenableFuture</code>。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>使用 <code>ListenableFuture</code> 一个最重要的原因就是：可以基于他实现负责的异步执行链。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;RowKey&gt; rowKeyFuture = indexService.lookUp(query);</span><br><span class="line">AsyncFunction&lt;RowKey, QueryResult&gt; queryFunction =</span><br><span class="line">  new AsyncFunction&lt;RowKey, QueryResult&gt;() &#123;</span><br><span class="line">    public ListenableFuture&lt;QueryResult&gt; apply(RowKey rowKey) &#123;</span><br><span class="line">      return dataService.read(rowKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">ListenableFuture&lt;QueryResult&gt; queryFuture =</span><br><span class="line">    Futures.transformAsync(rowKeyFuture, queryFunction, queryExecutor);</span><br></pre></td></tr></table></figure><p>很多不能被 <code>Future</code> 支持的方法可以通过 <code>ListenableFuture</code> 被高效地支持。不同的操作可能被不同的执行器执行，而且一个 <code>ListenableFuture</code> 可以有多个响应操作。</p><p>当 <code>ListenableFuture</code> 有多个后续操作的时候，这样的操作称为：“扇出”。当它依赖多个输入 future 同时完成时，称作“扇入”。可以参考 <a href="https://google.github.io/guava/releases/snapshot/api/docs/src-html/com/google/common/util/concurrent/Futures.html#line.1276" target="_blank" rel="noopener"><code>Futures.allAsList</code>的实现</a>。 </p><table><thead><tr><th>方法</th><th>描述</th><th>参考</th></tr></thead><tbody><tr><td><a href=""><code>transformAsync(ListenableFuture&lt;A&gt;, AsyncFunction&lt;A, B&gt;, Executor)</code></a></td><td>返回新的 <code>ListenableFuture</code>，它是给定 <code>AsyncFunction</code> 结合的结果</td><td><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#transformAsync-com.google.common.util.concurrent.ListenableFuture-com.google.common.util.concurrent.AsyncFunction-" target="_blank" rel="noopener"><code>transformAsync(ListenableFuture&lt;A&gt;, AsyncFunction&lt;A, B&gt;)</code></a></td></tr><tr><td><a href=""><code>transform(ListenableFuture&lt;A&gt;, Function&lt;A, B&gt;, Executor)</code></a></td><td>返回新的 <code>ListenableFuture</code>,它是给定 <code>Function</code> 结合的结果</td><td><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#transform-com.google.common.util.concurrent.ListenableFuture-com.google.common.base.Function-" target="_blank" rel="noopener"><code>transform(ListenableFuture&lt;A&gt;, Function&lt;A, B&gt;)</code></a> </td></tr><tr><td><a href=""><code>allAsList(Iterable&lt;ListenableFuture&lt;V&gt;&gt;)</code></a></td><td>返回一个 <code>ListenableFuture</code>,它的值是一个输入 futures 的值的按序列表，任何一个 future 的失败都会导致最后结果的失败</td><td><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#allAsList-com.google.common.util.concurrent.ListenableFuture...-" target="_blank" rel="noopener"><code>allAsList(ListenableFuture&lt;V&gt;...)</code></a></td></tr><tr><td><a href=""><code>successfulAsList(Iterable&lt;ListenableFuture&lt;V&gt;&gt;)</code></a></td><td>返回一个 <code>ListenableFuture</code>,它的值是一个输入 futures 的成功执行值的按序列表，对于取消或者失败的任务，对应的值是 <code>null</code></td><td><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#successfulAsList-com.google.common.util.concurrent.ListenableFuture...-" target="_blank" rel="noopener"><code>successfulAsList(ListenableFuture&lt;V&gt;...)</code></a></td></tr></tbody></table><p><code>AsyncFunction&lt;A, B&gt;</code> 提供了一个方法：<code>ListenableFuture&lt;B&gt; apply(A input)</code>。可以被用来异步转换一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ListenableFuture&lt;QueryResult&gt;&gt; queries;</span><br><span class="line">// The queries go to all different data centers, but we want to wait until they&apos;re all done or failed.</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;List&lt;QueryResult&gt;&gt; successfulQueries = Futures.successfulAsList(queries);</span><br><span class="line"></span><br><span class="line">Futures.addCallback(successfulQueries, callbackOnSuccessfulQueries);</span><br></pre></td></tr></table></figure><h1 id="避免嵌套-Future"><a href="#避免嵌套-Future" class="headerlink" title="避免嵌套 Future"></a>避免嵌套 Future</h1><p>在使用通用接口返回 <code>Future</code> 的代码中，很有可能会嵌套 <code>Future</code>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">executorService.submit(new Callable&lt;ListenableFuture&lt;Foo&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public ListenableFuture&lt;Foo&gt; call() &#123;</span><br><span class="line">    return otherExecutorService.submit(otherCallable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述代码将会返回：<code>ListenableFuture&lt;ListenableFuture&lt;Foo&gt;&gt;</code>。这样的代码是不正确的，因为外层 future 的取消操作不能传递到内层的 future。此外，一个常犯的错误是：使用 <code>get()</code> 或者 listener 来检测其它 future 的失败。为了避免这样的情况，Guava 所有处理 future 的方法（以及一些来自 JDK 的代码）具有安全解决嵌套的版本。</p><h1 id="CheckedFuture"><a href="#CheckedFuture" class="headerlink" title="CheckedFuture"></a>CheckedFuture</h1><p>Guava 也提供 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/CheckedFuture.html" target="_blank" rel="noopener"><code>CheckedFuture&lt;V, X extends Exception&gt;</code></a> 接口。</p><p><code>CheckedFuture</code> 是这样的一个 <code>ListenableFuture</code>：具有多个可以抛出受保护异常的 <code>get</code> 方法。这使得创建一个执行逻辑可能抛出异常的 future 变得容易。使用 <a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#makeChecked-com.google.common.util.concurrent.ListenableFuture-com.google.common.base.Function-" target="_blank" rel="noopener"><code>Futures.makeChecked(ListenableFuture&lt;V&gt;, Function&lt;Exception, X&gt;)</code></a>可以将 <code>ListenableFuture</code> 转换为 <code>CheckedFuture</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 Guava 中 &lt;a href=&quot;https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ListenableFuture&lt;/a&gt; 的学习介绍。欢迎加入学习项目： &lt;a href=&quot;https://github.com/JavaMilk/LearningGuava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LearningGuava&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Guava" scheme="http://mindawei.github.io/categories/Guava/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="Guava" scheme="http://mindawei.github.io/tags/Guava/"/>
    
      <category term="Concurrency" scheme="http://mindawei.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Guava学习之CharMatcher</title>
    <link href="http://mindawei.github.io/2018/03/17/Guava%E5%AD%A6%E4%B9%A0%E4%B9%8BCharMatcher/"/>
    <id>http://mindawei.github.io/2018/03/17/Guava学习之CharMatcher/</id>
    <published>2018-03-17T09:50:27.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 Guava 中 <a href="https://github.com/google/guava/wiki/StringsExplained#charmatcher" target="_blank" rel="noopener">CharMatcher</a> 的学习介绍。欢迎加入学习项目： <a href="https://github.com/JavaMilk/LearningGuava" target="_blank" rel="noopener">LearningGuava</a>。</p><a id="more"></a><p>以下参考：</p><ul><li><a href="https://github.com/google/guava/wiki/StringsExplained#charmatcher" target="_blank" rel="noopener">官方文档</a>。</li><li><a href="http://www.importnew.com/15230.html" target="_blank" rel="noopener">Guava 是个风火轮之基础工具(3)</a>。</li></ul><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>之前，Guava 中的 <code>StringUtil</code> 在无节制地增长，具有很多方法，如：</p><ul><li><code>allAscii</code></li><li><code>collapse</code></li><li><code>collapseControlChars</code></li><li><code>collapseWhitespace</code></li><li><code>lastIndexNotOf</code></li><li><code>numSharedChars</code></li><li><code>removeChars</code></li><li><code>removeCrLf</code></li><li><code>retainAllChars</code></li><li><code>strip</code></li><li><code>stripAndCollapse</code></li><li><code>stripNonDigits</code></li></ul><p>这些函数本质上是以下两个方面的乘积（M x N 种情况）：</p><ol><li>何如定义一个“匹配”的字符？ （M 种情况）</li><li>对“匹配”的字符进行怎样的操作？ （N 种情况）</li></ol><p>为了解决这样的爆炸式增长，Guava 提供了 <code>CharMatcher</code>。一个 <code>CharMacher</code> 实例本身，界定了一个匹配字符的集合，而 CharMacher 实例的方法，解决了要对匹配字符做什么的问题。然后我们就可以用最小化的 API 来处理字符匹配和字符操作，<strong>把 M×N 的复杂度下降到了 M+N</strong>。</p><p>直观地说，你可以把 <code>CharMatcher</code> 看做是一些特别字符串的表示，例如：数字、空格等。而事实上，<code>CharMatcher</code> 只是一个针对字符串的布尔断言（它实现了 <code>Predicate&lt;Character&gt;</code>），但考虑到“所有空白字符串”、“所有小写单词”等相关需求是很普遍的，Guava 还是为字符串提供了专门的语法和 API。</p><p><code>CharMatcher</code> 的功能主要在于对特定类或字符串执行这些操作：<code>trimming</code>、<code>collapsing</code>、<code>removing</code>、<code>retaining</code> 等。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="创建-CharMatcher"><a href="#创建-CharMatcher" class="headerlink" title="创建 CharMatcher"></a>创建 CharMatcher</h2><p>很多需求都可以被 <code>CharMatcher</code> 的工厂方法满足：</p><ul><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#any--" target="_blank" rel="noopener"><code>any()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#none--" target="_blank" rel="noopener"><code>none()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#whitespace--" target="_blank" rel="noopener"><code>whitespace()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#breakingWhitespace--" target="_blank" rel="noopener"><code>breakingWhitespace()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#invisible--" target="_blank" rel="noopener"><code>invisible()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#digit--" target="_blank" rel="noopener"><code>digit()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#javaLetter--" target="_blank" rel="noopener"><code>javaLetter()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#javaDigit--" target="_blank" rel="noopener"><code>javaDigit()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#javaLetterOrDigit--" target="_blank" rel="noopener"><code>javaLetterOrDigit()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#javaIsoControl--" target="_blank" rel="noopener"><code>javaIsoControl()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#javaLowerCase--" target="_blank" rel="noopener"><code>javaLowerCase()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#javaUpperCase--" target="_blank" rel="noopener"><code>javaUpperCase()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#ascii--" target="_blank" rel="noopener"><code>ascii()</code></a></li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#singleWidth--" target="_blank" rel="noopener"><code>singleWidth()</code></a></li></ul><p>其它一些常用的获得一个 <code>CharMatcher</code> 的方法包括：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#anyOf-java.lang.CharSequence-" target="_blank" rel="noopener"><code>anyOf(CharSequence)</code></a></td><td>表明你想匹配的所有字符，例如：<code>CharMatcher.anyOf(&quot;aeiou&quot;)</code> 可以匹配小写元音字母。</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#is-char-" target="_blank" rel="noopener"><code>is(char)</code></a></td><td>表明你想匹配的一个确定的字符。</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#inRange-char-char-" target="_blank" rel="noopener"><code>inRange(char, char)</code></a></td><td>表明你想匹配的一个字符范围，例如：<code>CharMatcher.inRange(&#39;a&#39;, &#39;z&#39;)</code>。</td></tr></tbody></table><p>此外，<code>CharMatcher</code> 还有这些方法：<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#negate--" target="_blank" rel="noopener"><code>negate()</code></a>、<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#and-com.google.common.base.CharMatcher-" target="_blank" rel="noopener"><code>and(CharMatcher)</code></a>、<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#or-com.google.common.base.CharMatcher-" target="_blank" rel="noopener"><code>or(CharMatcher)</code></a>。这些方法可以为 <code>CharMatcher</code> 提供方便的布尔运算。</p><h2 id="使用-CharMatcher"><a href="#使用-CharMatcher" class="headerlink" title="使用 CharMatcher"></a>使用 CharMatcher</h2><p><code>CharMatcher</code> 提供了很多方法来对匹配的字符序列 <code>CharSequence</code> 进行操作。以下只是列出了一些常用方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#collapseFrom-java.lang.CharSequence-char-" target="_blank" rel="noopener"><code>collapseFrom(CharSequence, char)</code></a></td><td>将一组连续匹配的字符串替换为一个指定的字符。例如：<code>WHITESPACE.collapseFrom(string, &#39; &#39;)</code> 可以将连续的空字符串替换为单个字符。</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#matchesAllOf-java.lang.CharSequence-" target="_blank" rel="noopener"><code>matchesAllOf(CharSequence)</code></a></td><td>测试字符序列是否全部匹配。例如：<code>ASCII.matchesAllOf(string)</code> 可以测试字符是否全部是 ASCII。</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#removeFrom-java.lang.CharSequence-" target="_blank" rel="noopener"><code>removeFrom(CharSequence)</code></a></td><td>将匹配的字符序列移除</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#retainFrom-java.lang.CharSequence-" target="_blank" rel="noopener"><code>retainFrom(CharSequence)</code></a></td><td>将没有匹配的字符序列移除</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#trimFrom-java.lang.CharSequence-" target="_blank" rel="noopener"><code>trimFrom(CharSequence)</code></a></td><td>去除开头和结尾匹配的部分</td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/CharMatcher.html#replaceFrom-java.lang.CharSequence-java.lang.CharSequence-" target="_blank" rel="noopener"><code>replaceFrom(CharSequence, CharSequence)</code></a></td><td>将匹配的字符替换为给定的序列</td></tr></tbody></table><h2 id="方法分类"><a href="#方法分类" class="headerlink" title="方法分类"></a>方法分类</h2><p>根据函数的返回值和名称将这些方法分为三类。</p><p>第一类是判定型函数，判断 <code>CharMacher</code> 和入参字符串的匹配关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CharMatcher.is(&apos;a&apos;).matchesAllOf(&quot;aaa&quot;);//true</span><br><span class="line">CharMatcher.is(&apos;a&apos;).matchesAnyOf(&quot;aba&quot;);//true</span><br><span class="line">CharMatcher.is(&apos;a&apos;).matchesNoneOf(&quot;aba&quot;);//true</span><br></pre></td></tr></table></figure></p><p>第二类是计数型函数，查找入参字符串中第一次、最后一次出现目标字符的位置，或者目标字符出现的次数，比如 <code>indexIn</code>，<code>lastIndexIn</code> 和 <code>countIn</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharMatcher.is(&apos;a&apos;).countIn(&quot;aaa&quot;); // 3</span><br><span class="line">CharMatcher.is(&apos;a&apos;).indexIn(&quot;java&quot;); // 1</span><br></pre></td></tr></table></figure></p><p>第三类就是对匹配字符的操作。包括 <code>removeFrom</code>、<code>retainFrom</code>、<code>replaceFrom</code>、<code>trimFrom</code>、<code>collapseFrom</code> 等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CharMatcher.is(&apos;a&apos;).retainFrom(&quot;bazaar&quot;); // &quot;aaa&quot;</span><br><span class="line">CharMatcher.is(&apos;a&apos;).removeFrom(&quot;bazaar&quot;); // &quot;bzr&quot;</span><br><span class="line">CharMatcher.anyOf(&quot;ab&quot;).trimFrom(&quot;abacatbab&quot;); // &quot;cat&quot;</span><br></pre></td></tr></table></figure></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>源码有很多行，主要的逻辑是这样的：</p><ul><li><code>CharMatcher</code> 是个抽象类，内部有一些私有的实现类，通过一些工厂函数 <code>is</code>、<code>anyOf</code> 等工厂函数创建对应的实例（固定的是单例，变化的会创建一个具体实例）。</li><li>不同的实例主要实现的是 <code>CharMatcher</code> 中的 <code>matches</code> 方法，这样就实现了不同策略的匹配器。</li><li>基于上述匹配方法 <code>matches</code>，可以进行统计工作（<code>countIn</code>等）、查找工作（<code>indexIn</code>等）、修改工作（<code>trimFrom</code>）等。</li></ul><p>这样的设计最基础的工作就是：把匹配部分进行抽象。此外，在具体实现过程中也有较多的优化，就不一一列出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 Guava 中 &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#charmatcher&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CharMatcher&lt;/a&gt; 的学习介绍。欢迎加入学习项目： &lt;a href=&quot;https://github.com/JavaMilk/LearningGuava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LearningGuava&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Guava" scheme="http://mindawei.github.io/categories/Guava/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="Guava" scheme="http://mindawei.github.io/tags/Guava/"/>
    
      <category term="String" scheme="http://mindawei.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Guava学习之Splitter</title>
    <link href="http://mindawei.github.io/2018/03/17/Guava%E5%AD%A6%E4%B9%A0%E4%B9%8BSplitter/"/>
    <id>http://mindawei.github.io/2018/03/17/Guava学习之Splitter/</id>
    <published>2018-03-17T09:36:37.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 Guava 中 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html" target="_blank" rel="noopener">Splitter</a> 的学习介绍。欢迎加入学习项目： <a href="https://github.com/JavaMilk/LearningGuava" target="_blank" rel="noopener">LearningGuava</a>。</p><a id="more"></a><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>以下参考：<a href="https://github.com/google/guava/wiki/StringsExplained#splitter" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 中关于分词的工具类会有一些古怪的行为。例如：<code>String.split</code> 函数会悄悄地丢弃尾部分割符，而 <code>StringTokenizer</code> 处理5个空格字符串，结果将会什么都没有。 </p><p>问题：<code>&quot;,a,,b,&quot;.split(&quot;,&quot;)</code> 的结果是什么？</p><ol><li>“”, “a”, “”, “b”, “”</li><li><code>null</code>, “a”, <code>null</code>, “b”, <code>null</code></li><li>“a”, <code>null</code>, “b”</li><li>“a”, “b”</li><li>以上都不是</li></ol><p>正确答案是：5 以上都不是，应该是 <code>&quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;</code>。只有尾随的空字符串被跳过。这样的结果很令人费解。</p><p>Splitter 可以让你使用一种非常简单流畅的模式来控制这些令人困惑的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Splitter.on(&apos;,&apos;)</span><br><span class="line">    .trimResults()</span><br><span class="line">    .omitEmptyStrings()</span><br><span class="line">    .split(&quot;foo,bar,,   qux&quot;);</span><br></pre></td></tr></table></figure></p><p>以上代码将会返回 <code>Iterable&lt;String&gt;</code> ，包含 “foo”、 “bar”、 “qux”。一个 <code>Splitter</code>  可以通过这些来进行划分：<code>Pattern</code>、<code>char</code>、 <code>String</code>、<code>CharMatcher</code>。</p><p>如果你希望返回的是 <code>List</code> 的话，可以使用这样的代码 <code>Lists.newArrayList(splitter.split(string))</code>。</p><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><table><thead><tr><th>方法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#on-char-" target="_blank" rel="noopener"><code>Splitter.on(char)</code></a></td><td>基于特定字符划分</td><td><code>Splitter.on(&#39;;&#39;)</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#on-com.google.common.base.CharMatcher-" target="_blank" rel="noopener"><code>Splitter.on(CharMatcher)</code></a></td><td>基于某些类别划分</td><td><code>Splitter.on(&#39;;&#39;)</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#on-java.lang.String-" target="_blank" rel="noopener"><code>Splitter.on(String)</code></a></td><td>基于字符串划分</td><td><code>Splitter.on(CharMatcher.BREAKING_WHITESPACE)</code><br><code>Splitter.on(CharMatcher.anyOf(&quot;;,.&quot;))</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#on-java.util.regex.Pattern-" target="_blank" rel="noopener"><code>Splitter.on(Pattern)</code></a><br><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#onPattern-java.lang.String-" target="_blank" rel="noopener"><code>Splitter.onPattern(String)</code></a></td><td>基于正则表达式划分</td><td><code>Splitter.on(&quot;, &quot;)</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#fixedLength-int-" target="_blank" rel="noopener"><code>Splitter.fixedLength(int)</code></a></td><td>按指定长度划分，最后部分可以小于指定长度但不能为空</td><td><code>Splitter.fixedLength(3)</code></td></tr></tbody></table><h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><table><thead><tr><th>方法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#omitEmptyStrings--" target="_blank" rel="noopener"><code>omitEmptyStrings()</code></a></td><td>移去结果中的空字符串</td><td><code>Splitter.on(&#39;,&#39;).omitEmptyStrings().split(&quot;a,,c,d&quot;)</code> 返回 <code>&quot;a&quot;, &quot;c&quot;, &quot;d&quot;</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#trimResults--" target="_blank" rel="noopener"><code>trimResults()</code></a></td><td>将结果中的空格删除，等价于<code>trimResults(CharMatcher.WHITESPACE)</code></td><td><code>Splitter.on(&#39;,&#39;).trimResults().split(&quot;a, b, c, d&quot;)</code> 返回 <code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#trimResults-com.google.common.base.CharMatcher-" target="_blank" rel="noopener"><code>trimResults(CharMatcher)</code></a></td><td>移除匹配字符</td><td><code>Splitter.on(&#39;,&#39;).trimResults(CharMatcher.is(&#39;_&#39;)).split(&quot;_a ,_b_ ,c__&quot;)</code> 返回 <code>&quot;a &quot;, &quot;b_ &quot;, &quot;c&quot;</code></td></tr><tr><td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html#limit-int-" target="_blank" rel="noopener"><code>limit(int)</code></a></td><td>达到指定数目后停止字符串的划分</td><td><code>Splitter.on(&#39;,&#39;).limit(3).split(&quot;a,b,c,d&quot;)</code> 返回 <code>&quot;a&quot;, &quot;b&quot;, &quot;c,d&quot;</code></td></tr></tbody></table><h2 id="Splitter-MapSplitter"><a href="#Splitter-MapSplitter" class="headerlink" title="Splitter.MapSplitter"></a>Splitter.MapSplitter</h2><p>以下参考：<a href="http://www.importnew.com/15227.html" target="_blank" rel="noopener">Guava 是个风火轮之基础工具(2)</a>。</p><p>通过 <code>Splitter</code> 的 <code>withKeyValueSeparator</code> 方法可以获得 <code>Joiner.MapJoiner</code> 对象。</p><p><code>MapSpliter</code> 只有一个公共方法，如下所示。可以看到返回的对象是 <code>Map&lt;String, String&gt;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, String&gt; split(CharSequence sequence)</span><br></pre></td></tr></table></figure></p><p>以下代码将返回这样的 <code>Map</code>: <code>{&quot;1&quot;:&quot;2&quot;, &quot;3&quot;:&quot;4&quot;}</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Splitter.on(&quot;#&quot;).withKeyValueSeparator(&quot;:&quot;).split(&quot;1:2#3:4&quot;);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<code>MapSplitter</code> 对键值对格式有着严格的校验，下例会抛出 <code>java.lang.IllegalArgumentException</code> 异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Splitter.on(&quot;#&quot;).withKeyValueSeparator(&quot;:&quot;).split(&quot;1:2#3:4:5&quot;);</span><br></pre></td></tr></table></figure></p><p>因此，如果希望使用 <code>MapSplitter</code> 来拆分 KV 结构的字符串，需要保证键-值分隔符和键值对之间的分隔符不会称为键或值的一部分。也许是出于类似方面的考虑，MapSplitter 被加上了 <code>@Beta</code> 注解（未来不保证兼容，甚至可能会移除）。所以一般推荐使用 <code>JSON</code> 而不是 <code>MapJoiner</code> + <code>MapSplitter</code>。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>以下参考：<a href="http://www.importnew.com/15227.html" target="_blank" rel="noopener">Guava 是个风火轮之基础工具(2)</a>。</p><p><code>Splitter</code> 的实现中有十分明显的策略模式和模板模式，有各种神乎其技的方法覆盖，还有 Guava 久负盛名的迭代技巧和惰性计算。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p><code>Splitter</code> 类有 4 个成员变量:</p><ul><li><code>CharMatcher trimmer</code>：用于描述删除拆分结果的前后指定字符的策略。</li><li><code>boolean omitEmptyStrings</code>：用于控制是否删除拆分结果中的空字符串。</li><li><code>Strategy strategy</code>：用于帮助实现策略模式。</li><li><code>int limit</code>：用于控制拆分的结果个数。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><code>Splitter</code> 可以根据字符、字符串、正则、长度还有 Guava 自己的字符匹配器 <code>CharMatcher</code> 来拆分字符串，基本上每种匹配模式的查找方法都不太一样，但是字符拆分的基本框架又是不变的，所以策略模式正好合用。</p><p>策略接口的定义很简单，就是传入一个 <code>Splitter</code> 和一个待拆分的字符串，返回一个迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private interface Strategy &#123;</span><br><span class="line">  Iterator&lt;String&gt; iterator(Splitter splitter, CharSequence toSplit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个工厂函数创建最后都需要去调用基本的私有构造函数。这个创建过程中，主要是提供一个可以创建 <code>Iterator&lt;String&gt;</code> 的 <code>Strategy</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Splitter(Strategy strategy, boolean omitEmptyStrings, CharMatcher trimmer, int limit)；</span><br></pre></td></tr></table></figure></p><p>以 <code>Splitter on(final CharMatcher separatorMatcher)</code> 创建函数为例，这里返回的是 <code>SplittingIterator</code> (它是个抽象类，继承了 <code>AbstractIterator</code>，而 <code>AbstractIterator</code> 继承了 <code>Iterator</code>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Splitter on(final CharMatcher separatorMatcher) &#123;</span><br><span class="line">  checkNotNull(separatorMatcher);</span><br><span class="line">  return new Splitter(</span><br><span class="line">      new Strategy() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public SplittingIterator iterator(Splitter splitter, final CharSequence toSplit) &#123;</span><br><span class="line">          return new SplittingIterator(splitter, toSplit) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            int separatorStart(int start) &#123;</span><br><span class="line">              return separatorMatcher.indexIn(toSplit, start);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            int separatorEnd(int separatorPosition) &#123;</span><br><span class="line">              return separatorPosition + 1;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SplittingIterator</code> 需要覆盖实现 <code>separatorStart</code> 和 <code>separatorEnd</code> 两个方法才能实例化。这两个方法也是 <code>SplittingIterator</code> 用到的模板模式的重要组成。</p><h2 id="惰性迭代器与模板模式"><a href="#惰性迭代器与模板模式" class="headerlink" title="惰性迭代器与模板模式"></a>惰性迭代器与模板模式</h2><p><a href="https://baike.baidu.com/item/%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97/3081216" target="_blank" rel="noopener">惰性计算</a>目的是要最小化计算机要做的工作，即把计算推迟到不得不算的时候进行。Java中的惰性计算可以参考<a href="https://my.oschina.net/bairrfhoinn/blog/142985" target="_blank" rel="noopener">《你应该更新的 Java 知识之惰性求值：Supplier 和 Guava》</a>。</p><p>Guava 中的迭代器使用了惰性计算的技巧，它不是一开始就算好结果放在列表或集合中，而是在调用 <code>hasNext</code> 方法判断迭代是否结束时才去计算下一个元素。</p><h3 id="AbstractIterator"><a href="#AbstractIterator" class="headerlink" title="AbstractIterator"></a>AbstractIterator</h3><p>为了看懂 Guava 的惰性迭代器实现，我们要从 <code>AbstractIterator</code> 开始。</p><p><code>AbstractIterator</code> 使用私有的枚举变量 <code>state</code> 来记录当前的迭代进度，比如是否找到了下一个元素，迭代是否结束等。<code>AbstractIterator</code> 有一个抽象方法 <code>computeNext</code>，负责计算下一个元素。由于 <code>state</code> 是私有变量，而迭代是否结束只有在调用 <code>computeNext</code> 的过程中才知道，于是提供了一个保护的 <code>endOfData</code> 方法，允许子类将 <code>state</code> 设置为 <code>State.DONE</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private enum State &#123;</span><br><span class="line">  READY,</span><br><span class="line">  NOT_READY,</span><br><span class="line">  DONE,</span><br><span class="line">  FAILED,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AbstractIterator</code> 实现了迭代器最重要的两个方法，<code>hasNext</code> 和 <code>next</code>。</p><p><code>hasNext</code> 很容易理解，一上来先判断迭代器当前状态，如果已经结束，就返回 <code>false</code>；如果已经找到下一个元素，就返回 <code>true</code>，不然就试着找找下一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final boolean hasNext() &#123;</span><br><span class="line">  checkState(state != State.FAILED);</span><br><span class="line">  switch (state) &#123;</span><br><span class="line">    case READY:</span><br><span class="line">      return true;</span><br><span class="line">    case DONE:</span><br><span class="line">      return false;</span><br><span class="line">    default:</span><br><span class="line">  &#125;</span><br><span class="line">  return tryToComputeNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>next</code> 则是先判断是否还有下一个元素，属于防御式编程，先对自己做保护；然后把状态复原到还没找到下一个元素，然后返回结果。至于为什么要把 <code>next</code> 置为 <code>null</code>，可能是帮助 JVM 回收对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public final T next() &#123;</span><br><span class="line">   if (!hasNext()) &#123;</span><br><span class="line">     throw new NoSuchElementException();</span><br><span class="line">   &#125;</span><br><span class="line">   state = State.NOT_READY;</span><br><span class="line">   T result = next;</span><br><span class="line">   next = null;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><code>tryToComputeNext</code> 可以认为是对模板方法 <code>computeNext</code> 的包装调用，首先把状态置为失败，然后才调用 computeNext。这样一来，如果计算下一个元素的过程中发生 <code>RuntimeException</code>，整个迭代器的状态就是 <code>State.FAILED</code>，一旦收到任何调用都会抛出异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private boolean tryToComputeNext() &#123;</span><br><span class="line">    state = State.FAILED; // 暂时悲观</span><br><span class="line">    next = computeNext();</span><br><span class="line">    if (state != State.DONE) &#123;</span><br><span class="line">      state = State.READY;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>AbstractIterator</code> 的代码就这些，我们现在知道了它的子类需要覆盖实现 <code>computeNext</code> 方法，然后在迭代结束时调用 <code>endOfData</code>。接下来看看 <code>SplittingIterator</code> 的实现。</p><h3 id="SplittingIterator"><a href="#SplittingIterator" class="headerlink" title="SplittingIterator"></a>SplittingIterator</h3><p><code>SplittingIterator</code> 还是一个抽象类，虽然实现了 <code>computeNext</code> 方法，但是它又定义了两个虚函数:</p><ul><li><code>separatorStart</code>： 返回分隔符在指定下标之后第一次出现的下标</li><li><code>separatorEnd</code>： 返回分隔符在指定下标后面第一个不包含分隔符的下标。</li></ul><p>之前的策略模式中我们可以看到，这两个函数在不同的策略中有各自不同的覆盖实现，在 <code>SplittingIterator</code> 中，这两个函数就是模板函数。</p><p>接下来看看 <code>SplittingIterator</code> 的核心函数 <code>computeNext</code>，这个函数一直在维护的两个内部全局变量: <code>offset</code> 和 <code>limit</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected String computeNext() &#123;</span><br><span class="line">    // 返回的字符串介于上一个分隔符和下一个分隔符之间。</span><br><span class="line"> // nextStart 是返回子串的起始位置，offset 是下次开启寻找分隔符的地方。 </span><br><span class="line">    int nextStart = offset;</span><br><span class="line">    while (offset != -1) &#123;</span><br><span class="line">      int start = nextStart;</span><br><span class="line">      int end;</span><br><span class="line"></span><br><span class="line">// 找 offset 之后第一个分隔符出现的位置</span><br><span class="line">      int separatorPosition = separatorStart(offset);</span><br><span class="line">      if (separatorPosition == -1) &#123;</span><br><span class="line">  // 处理没找到的情况</span><br><span class="line">        end = toSplit.length();</span><br><span class="line">        offset = -1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">  // 处理找到的情况</span><br><span class="line">        end = separatorPosition;</span><br><span class="line">        offset = separatorEnd(separatorPosition);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 处理的是第一个字符就是分隔符的特殊情况</span><br><span class="line">      if (offset == nextStart) &#123;</span><br><span class="line">        // 发生情况：空字符串 或者 整个字符串都没有匹配。</span><br><span class="line">        // offset 需要增加来寻找这个位置之后的分隔符，</span><br><span class="line">  // 但是没有改变接下来返回字符串的 start 的位置，</span><br><span class="line">  // 所以此时它们二者相同。</span><br><span class="line">        offset++;</span><br><span class="line">        if (offset &gt; toSplit.length()) &#123;</span><br><span class="line">          offset = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 根据 trimmer 来对找到的元素做前处理，比如去除空白符之类的。</span><br><span class="line">      while (start &lt; end &amp;&amp; trimmer.matches(toSplit.charAt(start))) &#123;</span><br><span class="line">        start++;</span><br><span class="line">      &#125;</span><br><span class="line">// 根据 trimmer 来对找到的元素做后处理，比如去除空白符之类的。</span><br><span class="line">      while (end &gt; start &amp;&amp; trimmer.matches(toSplit.charAt(end - 1))) &#123;</span><br><span class="line">        end--;</span><br><span class="line">      &#125;</span><br><span class="line">// 根据需要去除那些是空字符串的元素，trim完之后变成空字符串的也会被去除。</span><br><span class="line">      if (omitEmptyStrings &amp;&amp; start == end) &#123;</span><br><span class="line">        // Don&apos;t include the (unused) separator in next split string.</span><br><span class="line">        nextStart = offset;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 判断 limit，</span><br><span class="line">      if (limit == 1) &#123;</span><br><span class="line">        // The limit has been reached, return the rest of the string as the</span><br><span class="line">        // final item. This is tested after empty string removal so that</span><br><span class="line">        // empty Strings do not count towards the limit.</span><br><span class="line">        end = toSplit.length();</span><br><span class="line">  // 调整 end 指针的位置标记 offset 为 -1，下一次再调用 computeNext </span><br><span class="line">  // 的时候就发现 offset 已经是 -1 了，然后就返回 endOfData 表示迭代结束。</span><br><span class="line">        offset = -1;</span><br><span class="line">        // Since we may have changed the end, we need to trim it again.</span><br><span class="line">        while (end &gt; start &amp;&amp; trimmer.matches(toSplit.charAt(end - 1))) &#123;</span><br><span class="line">          end--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">  // 还没到 limit 的极限，就让 limit 自减</span><br><span class="line">        limit--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return toSplit.subSequence(start, end).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    return endOfData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 Guava 中 &lt;a href=&quot;http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Splitter.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Splitter&lt;/a&gt; 的学习介绍。欢迎加入学习项目： &lt;a href=&quot;https://github.com/JavaMilk/LearningGuava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LearningGuava&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Guava" scheme="http://mindawei.github.io/categories/Guava/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="Guava" scheme="http://mindawei.github.io/tags/Guava/"/>
    
      <category term="String" scheme="http://mindawei.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Guava学习之Joiner</title>
    <link href="http://mindawei.github.io/2018/03/17/Guava%E5%AD%A6%E4%B9%A0%E4%B9%8BJoiner/"/>
    <id>http://mindawei.github.io/2018/03/17/Guava学习之Joiner/</id>
    <published>2018-03-17T09:12:17.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 Guava 中 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Joiner.html" target="_blank" rel="noopener">Joiner</a> 的学习介绍。欢迎加入学习项目： <a href="https://github.com/JavaMilk/LearningGuava" target="_blank" rel="noopener">LearningGuava</a>。</p><a id="more"></a><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>以下参考：<a href="https://github.com/google/guava/wiki/StringsExplained#joiner" target="_blank" rel="noopener">官方文档</a>。</p><p>开发过程中，用分隔符连接字符串序列可能是一个比较繁琐的过程，但本不应该如此。<code>Joiner</code> 可以简化这个操作。</p><p>如果序列中包含 <code>null</code> 值，那么可以使用 <code>Joiner</code> 跳过 <code>null</code> 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 跳过 null 值</span><br><span class="line">result = Joiner.on(&quot;; &quot;).skipNulls().join(&quot;Harry&quot;, null, &quot;Ron&quot;, &quot;Hermione&quot;);</span><br><span class="line">Assert.assertEquals(result, &quot;Harry; Ron; Hermione&quot;);</span><br></pre></td></tr></table></figure></p><p>也可以通过 <code>useForNull(String)</code> 来将 <code>null</code> 值替换为指定的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 替换 null 值</span><br><span class="line">result = Joiner.on(&quot;; &quot;).useForNull(&quot;null&quot;).join(&quot;Harry&quot;, null, &quot;Ron&quot;, &quot;Hermione&quot;);</span><br><span class="line">Assert.assertEquals(result, &quot;Harry; null; Ron; Hermione&quot;);</span><br></pre></td></tr></table></figure></p><p>同样可以在对象上使用 <code>Joiner</code>,最终会调用对象的 <code>toString()</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用在对象上，会调用对象的 toString() 函数</span><br><span class="line">result = Joiner.on(&quot;,&quot;).join(Arrays.asList(1, 5, 7));</span><br><span class="line">Assert.assertEquals(result, &quot;1,5,7&quot;);</span><br></pre></td></tr></table></figure></p><p>对于 <code>Map</code> ,可以使用这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MapJoiner 的使用，将 map 转换为字符串</span><br><span class="line">Map map = ImmutableMap.of(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;);</span><br><span class="line">result = Joiner.on(&quot;; &quot;).withKeyValueSeparator(&quot;=&quot;).join(map);</span><br><span class="line">Assert.assertEquals(result, &quot;k1=v1; k2=v2&quot;);</span><br></pre></td></tr></table></figure></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>以下参考：<a href="http://www.importnew.com/15221.html" target="_blank" rel="noopener">Guava 是个风火轮之基础工具(1)</a>。</p><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p><code>Joiner</code> 的构造方法被设置成了私有，需要通过静态的 <code>on(String separator)</code> 或者 <code>on(char separator)</code> 函数初始化。 </p><h2 id="拼接基本函数"><a href="#拼接基本函数" class="headerlink" title="拼接基本函数"></a>拼接基本函数</h2><p><code>Joiner</code> 了中最为核心的函数就是 <code>&lt;A extends Appendable&gt; A appendTo(A appendable, Iterator&lt;?&gt; parts)</code>。作为全功能函数，其它所有的字符串拼接最终都会调用这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;A extends Appendable&gt; A appendTo(A appendable, Iterator&lt;?&gt; parts) throws IOException &#123;</span><br><span class="line">  checkNotNull(appendable);</span><br><span class="line">  if (parts.hasNext()) &#123;</span><br><span class="line">    appendable.append(toString(parts.next()));</span><br><span class="line">    while (parts.hasNext()) &#123;</span><br><span class="line">      appendable.append(separator);</span><br><span class="line">      appendable.append(toString(parts.next()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return appendable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的分析如下：</p><ul><li>这里的 <code>Appendable</code> 源码中传入的是实现该接口的 <code>StringBuilder</code>。</li><li>因为是公共方法，无法保证 <code>appendable</code> 值不为空，所以要先检查该值是否为空。</li><li><code>if ... while ...</code> 的结构确保末尾不会添加多余的分隔符。</li><li>通过本地 <code>toString</code> 方法，而不是直接调用对象的 <code>toString</code> 方法，这种做法提供了空指针保护。</li></ul><h2 id="不可能发生的异常"><a href="#不可能发生的异常" class="headerlink" title="不可能发生的异常"></a>不可能发生的异常</h2><p>在源码中，有个地方的处理值得关注一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder appendTo(StringBuilder builder, Iterator&lt;? extends Entry&lt;?, ?&gt;&gt; entries) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     appendTo((Appendable) builder, entries);</span><br><span class="line">   &#125; catch (IOException impossible) &#123;</span><br><span class="line">     throw new AssertionError(impossible);</span><br><span class="line">   &#125;</span><br><span class="line">   return builder;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里之所以 <code>IOException</code> 的变量名取名为 <code>impossible</code> 是因为：虽然 <code>Appendable</code> 接口的 <code>append</code> 方法会抛出 <code>IOException</code>，但是传入的 <code>StringBuilder</code> 在实现的时候并不会抛出改异常，所以为了适应这个接口，这里不得不捕捉异常。这样捕捉后的断言处理也就可以理解了。</p><h2 id="巧妙的可变长参数转换"><a href="#巧妙的可变长参数转换" class="headerlink" title="巧妙的可变长参数转换"></a>巧妙的可变长参数转换</h2><p>有一个添加的重载函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;A extends Appendable&gt; A appendTo(</span><br><span class="line">     A appendable, @NullableDecl Object first, @NullableDecl Object second, Object... rest)</span><br><span class="line">     throws IOException &#123;</span><br><span class="line">   return appendTo(appendable, iterable(first, second, rest));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>iterable</code> 函数将参数变为一个可以迭代的序列，该函数如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static Iterable&lt;Object&gt; iterable(</span><br><span class="line">      final Object first, final Object second, final Object[] rest) &#123;</span><br><span class="line">    checkNotNull(rest);</span><br><span class="line">    return new AbstractList&lt;Object&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public int size() &#123;</span><br><span class="line">        return rest.length + 2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public Object get(int index) &#123;</span><br><span class="line">        switch (index) &#123;</span><br><span class="line">          case 0:</span><br><span class="line">            return first;</span><br><span class="line">          case 1:</span><br><span class="line">            return second;</span><br><span class="line">          default:</span><br><span class="line">            return rest[index - 2];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>通过实现 <code>AbstractList</code> 的方式，巧妙地复用了编译器生成的数组，减少了对象创建的开销。这样的实现需要对迭代器有深入的了解，因为要确保实现能够满足迭代器接口各个函数的语义。</p><h2 id="Joiner-二次创建"><a href="#Joiner-二次创建" class="headerlink" title="Joiner 二次创建"></a>Joiner 二次创建</h2><p>因为 <code>Joiner</code> 创建后就是不可更改的了，所以为了实现 <code>useForNull</code> 和 <code>skipNulls</code> 等语义，源码会再次创建一个匿名类，并覆盖相应的方法。 </p><p><code>useForNull</code> 函数汇中为了防止重复调用 <code>useForNull</code> 和 <code>skipNulls</code>，还特意覆盖了这两个方法，一旦调用就抛出运行时异常。为什么不能重复调用 <code>useForNull</code> ？因为覆盖了 <code>toString</code> 方法，而覆盖实现中需要调用覆盖前的 <code>toString</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Joiner useForNull(final String nullText) &#123;</span><br><span class="line">  checkNotNull(nullText);</span><br><span class="line">  return new Joiner(this) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    CharSequence toString(@NullableDecl Object part) &#123;</span><br><span class="line">      return (part == null) ? nullText : Joiner.this.toString(part);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Joiner useForNull(String nullText) &#123;</span><br><span class="line">      throw new UnsupportedOperationException(&quot;already specified useForNull&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Joiner skipNulls() &#123;</span><br><span class="line">      throw new UnsupportedOperationException(&quot;already specified useForNull&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>skipNulls</code> 函数实现如下所示。个人比较奇怪的是 <code>skipNulls</code> 中为什么不禁止重复调用 <code>skipNulls</code> 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public Joiner skipNulls() &#123;</span><br><span class="line">  return new Joiner(this) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;A extends Appendable&gt; A appendTo(A appendable, Iterator&lt;?&gt; parts) throws IOException &#123;</span><br><span class="line">      checkNotNull(appendable, &quot;appendable&quot;);</span><br><span class="line">      checkNotNull(parts, &quot;parts&quot;);</span><br><span class="line">      while (parts.hasNext()) &#123;</span><br><span class="line">        Object part = parts.next();</span><br><span class="line">        if (part != null) &#123;</span><br><span class="line">          appendable.append(Joiner.this.toString(part));</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      while (parts.hasNext()) &#123;</span><br><span class="line">        Object part = parts.next();</span><br><span class="line">        if (part != null) &#123;</span><br><span class="line">          appendable.append(separator);</span><br><span class="line">          appendable.append(Joiner.this.toString(part));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return appendable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Joiner useForNull(String nullText) &#123;</span><br><span class="line">      throw new UnsupportedOperationException(&quot;already specified skipNulls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MapJoiner withKeyValueSeparator(String kvs) &#123;</span><br><span class="line">      throw new UnsupportedOperationException(&quot;can&apos;t use .skipNulls() with maps&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 Guava 中 &lt;a href=&quot;http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Joiner.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joiner&lt;/a&gt; 的学习介绍。欢迎加入学习项目： &lt;a href=&quot;https://github.com/JavaMilk/LearningGuava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LearningGuava&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Guava" scheme="http://mindawei.github.io/categories/Guava/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="Guava" scheme="http://mindawei.github.io/tags/Guava/"/>
    
      <category term="String" scheme="http://mindawei.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket介绍</title>
    <link href="http://mindawei.github.io/2018/03/14/WebSocket%E4%BB%8B%E7%BB%8D/"/>
    <id>http://mindawei.github.io/2018/03/14/WebSocket介绍/</id>
    <published>2018-03-14T02:09:44.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 WebSocket 变化的介绍，是对以下资料的摘录：</p><ul><li><a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">维基：WebSocket</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">《WebSocket 教程》</a></li><li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC 6455：The WebSocket Protocol</a></li></ul><a id="more"></a><h1 id="WebSocket-概览"><a href="#WebSocket-概览" class="headerlink" title="WebSocket 概览"></a>WebSocket 概览</h1><p>WebSocket 是一个计算机间的通信协议，它能够在单个 TCP 链接上构建一个双工的交流通道。WebSocket 协议的标准是由 IETE 在 2011年的 <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener"><strong>RFC 6455</strong></a> 中制定的。</p><p>WebSocket 是一个与 HTTP 并不相同的 TCP 的协议。WebSocket 和 HTTP 协议都是在7层网络模型（<a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener"><strong>OSI model</strong></a>）中的，并且都依赖第4层的 TCP 协议。尽管两者并不相同，但 <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener"><strong>RFC 6455</strong></a> 中声明 “WebSocket 是可以工作在 HTTP协议 的80和443端口之上的，并且能够支持 HTTP 代理和中介”，这使得 WebSocket 可以兼容 HTTP 协议。为了实现这个兼容目标，WebSocket 的<a href="https://en.wikipedia.org/wiki/Handshaking" target="_blank" rel="noopener"><strong>握手（handshake）</strong></a>使用了 <a href="https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header" target="_blank" rel="noopener"><strong>HTTP 的 Upgrade 头部</strong></a>，从而实现从 HTTP 协议转换为 WebSocket 协议的目标。</p><p>WebSocket 能够建立客户端和服务器间的双向通信，目前很多浏览器都已经支持该协议了。同样，服务端也需要提供相应的支持。</p><p>WebSocket 协议标志是 <code>ws</code>（WebSocket）和 <code>wss</code>（WebSocket Secure）。<br><img src="/images/00026/01.jpg" alt="协议标志" title="协议标志">  </p><h1 id="为什么需要-WebSocket"><a href="#为什么需要-WebSocket" class="headerlink" title="为什么需要 WebSocket"></a>为什么需要 WebSocket</h1><p>由于 HTTP 是客户端发起的单向请求，对于聊天室这样需要服务端推送信息的场景就不是很适合。当然，客户端可以通过<a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/" target="_blank" rel="noopener"><strong>“轮询”</strong></a>的方式来了解服务端的信息，但是这样的效率比较低，比较浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><p>和 HTTP 不同，WebSocket 是一个全双工协议，属于<a href="https://en.wikipedia.org/wiki/Push_technology" target="_blank" rel="noopener"><strong>服务器推送技术</strong></a>的一种。在 WebSocket 之前，在80端口可以通过 Comet 通道实现全双工。但是由于 TCP 握手和 HTTP 头部的开销，对于数据量不大的信息来说，这样的机制不是很高效。WebSocket 协议的目标就是解决这些问题并且提供相应的安全保障。</p><h1 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h1><p>WebSocket 建立连接的过程如下：</p><ol><li><p>客户端发送 WebSocket 握手请求（和 HTTP 一样, 每行要以 <code>\r\n</code> 结尾，最后要有一个额外的空行）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure></li><li><p>服务端回应握手请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，客户端发送的请求头部除了 <code>Upgrade</code> 外，还有 <code>Sec-WebSocket-Key</code> 字段，它是包含base64编码的随机字节，服务端需要在 <code>WebSocket-Accept</code> 字段中返回这个键的hash值。这是为了防止缓存代理重发之前的 WebSocket 会话。</p><p>通过类 HTTP 形式的握手形式，可以使得服务端在同一个端口处理 HTTP 或者 WebSocket 协议。一旦 WebSocket 握手完成，通信马上变换成一个与 HTTP 协议不同的双向通道。<br><img src="/images/00026/02.png" alt="WebSocket协议过程" title="WebSocket协议过程"> </p><p>此外，从安全的角度来说，提供 <code>Origin</code> 标签是很有必要的，可以避免跨站点的 WebSocket 劫持攻击。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>全双工的通道建立之后，传输的数据将会以尽可能小的格式进行封装：一个小的头部，紧跟着的是有效数据载体 <a href="https://en.wikipedia.org/wiki/Payload_(computing" target="_blank" rel="noopener"><strong>payload</strong></a>)。WebSocket 传输的内容被称为“消息”，这个消息可以被划分成多个数据帧。这样在只有一部分初始数据（完整数据还未准备好）的时候就可以提前发送数据了。通过扩展，可以同时多路复用多个数据流（这样可以避免大负载数据对 socket 的独占使用）。<br><img src="/images/00026/03.png" alt="数据格式" title="数据格式"> </p><p><strong>FIN</strong>（1 bit）<br>表明消息是否是最后一帧。第一条消息也可能是最后一帧。</p><p><strong>RSV1, RSV2, RSV3</strong>（每个都是1位）<br>必须是0，除非扩展定义了非0值的意义。如果收到非0值，并且没有具体的定义，那么接收端必须使连接失败。</p><p><strong>Opcode</strong>（4位）<br>声明 “Payload data” 的含义。如果收到一个未知编码，那么接收端必须使连接失败。目前有以下这些值：</p><ul><li><code>%x0</code> denotes a continuation frame，表明是一个持续帧。</li><li><code>%x1</code> denotes a text frame，表明是一个文本帧。</li><li><code>%x2</code> denotes a binary frame，表明是一个二进制帧。</li><li><code>%x3-7</code> are reserved for further non-control frames，为未来的非控制帧保留。</li><li><code>%x8</code> denotes a connection close，定义一个连接结束。</li><li><code>%x9</code> denotes a ping，表示 ping 操作。</li><li><code>%xA</code> denotes a pong，表示 pong 操作。</li><li><code>%xB-F</code> are reserved for further control frames，为未来的控制帧保留。</li></ul><p><strong> Mask</strong>（1 bit）<br>定义 “Payload data” 是否是隐秘的。如果设置为1，那么 <code>masking-key</code> 中会提供一个值，并且可以根据 <a href="https://tools.ietf.org/html/rfc6455#section-5.3" target="_blank" rel="noopener">5.3节</a> 取消对应的标志。所有客户端发送到服务端的帧都需要把这位设置为1。</p><p><strong>Payload length</strong>（7位 或 7+16位 或 7+64位）<br>表示 “Payload data” 的长度。分为这几种情况：</p><ul><li>如果是 0-125，那么就是实际长度。</li><li>如果是 126，那么接下来的2个字节作为一个16位的无符号整数，表示实际的长度。</li><li>如果是 127，那么接下来的8个字节作为一个64位的无符号整数，表示实际的长度。</li></ul><p>其中多字节表示的长度在网络中必须按序排列。值得注意的是，在所有例子中，长度必须按最短的表示方式表示。Payload 数据的长度是由 “Extension data” （扩展数据）和 “Extension data”（应用数据）组成的，当扩展数据的长度为0时，payload 数据的长度就是应用数据的长度。</p><p><strong>Masking-key</strong>（0位或者4位）<br>所有从客户端发送到服务端的数据帧都需要有一个32位的 <code>Masking-key</code>。当 <code>mask</code> 位被设置为1的时候，这个域存在；当 <code>mask</code> 位被设置为0的时候，这个域不存在。可以看 <a href="https://tools.ietf.org/html/rfc6455#section-5.3" target="_blank" rel="noopener">5.3节</a> 来进一步了解。</p><p><strong>Payload data</strong>（x+y位）<br>由 “Extension data”（扩展数据）和 “Application data”（应用数据）组成。</p><ul><li><strong>Extension data</strong>（x位）：扩展数据默认是0位，除非实现了一个扩展协议。每一个扩展的协议必须说明扩展数据的长度、长度是如何计算的、以及在握手阶段扩展是如何约定的。如果该部分数据存在，那么将会被记录到总的 payload 长度中。</li><li><strong>Application data</strong>（y位）：应用数据在扩展数据之后，应用数据的长度等于 payload 的长度减去扩展数据的长度。</li></ul><p><img src="/images/00026/04.png" alt="WebSocket 数据格式" title="WebSocket 数据格式"> </p><h1 id="其它资料"><a href="#其它资料" class="headerlink" title="其它资料"></a>其它资料</h1><p>进一步了解可以参考这些文档：</p><ul><li><a href="https://www.w3cschool.cn/html5/html5-websocket.html" target="_blank" rel="noopener">w3cschool</a></li><li><a href="http://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">HTML5 WebSocket</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket - Web APIs | MDN</a></li><li><a href="http://websocket.org/#" target="_blank" rel="noopener">websocket.org</a></li><li><a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations" target="_blank" rel="noopener">WebSocket 的实现比较</a></li><li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">WebSocket 是什么原理？为什么可以实现持久连接？</a></li></ul><p>推荐一款非常特别的 WebSocket 服务器：<a href="http://websocketd.com/" target="_blank" rel="noopener">Websocketd</a>。它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 WebSocket 变化的介绍，是对以下资料的摘录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/WebSocket&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基：WebSocket&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/05/websocket.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《WebSocket 教程》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 6455：The WebSocket Protocol&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://mindawei.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://mindawei.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="WebSocket" scheme="http://mindawei.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>JDK版本变化</title>
    <link href="http://mindawei.github.io/2018/03/13/JDK%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96/"/>
    <id>http://mindawei.github.io/2018/03/13/JDK版本变化/</id>
    <published>2018-03-13T15:21:10.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录Java版本的更新历史，主要是对以下文章的结合：</p><ul><li><a href="http://openjdk.java.net/projects/jdk/" target="_blank" rel="noopener">《openjdk 文档》</a></li><li><a href="http://blog.csdn.net/u010297957/article/details/50915631" target="_blank" rel="noopener">《Java - JCP、JSR等名词介绍》</a></li><li><a href="https://www.cnblogs.com/rese-t/p/7823378.html" target="_blank" rel="noopener">《从java1到java9每个版本都有什么新特性？》</a></li><li><a href="http://blog.csdn.net/postnull/article/details/78068060?locationNum=2&amp;fps=1" target="_blank" rel="noopener">《Java 9正式发布》</a></li><li><a href="https://www.oschina.net/news/93123/jdk10-release-candidate-phase" target="_blank" rel="noopener">《JDK 10 本周将进入候选发布阶段，新特性抢先看》</a></li><li><a href="http://www.infoq.com/cn/articles/is-java-out-of-date" target="_blank" rel="noopener">《Java 老矣，尚能饭否？》</a></li></ul><p>文章 Github 地址：<a href="https://github.com/mindawei/JDKHistory" target="_blank" rel="noopener">JDKHistory</a>。</p><a id="more"></a><h1 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h1><ul><li><a href="https://www.jcp.org/en/home/index" target="_blank" rel="noopener">JCP</a> 是 Java Community Process（Java社区进程）的简称，社会各界Java组成的社区，规划和领导Java的发展。</li><li><a href="http://openjdk.java.net/jeps/0" target="_blank" rel="noopener">JEP</a> 是 JDK Enhancement Proposals （Java 增强提案）的简称，JDK的版本变化将从这些提案中选取。</li><li>JSR 是 Java Specification Requests（Java规范请求）的简称，是 JCP 成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过会成为 JEP，最终会体现在未来的Java中。</li><li>TCK 是 Technology Compatibility Kit（技术兼容性测试）的简称， 如果一个平台型程序想要宣称自己兼容Java，就必须通过TCK测试</li></ul><h1 id="JDK-11"><a href="#JDK-11" class="headerlink" title="JDK 11"></a>JDK 11</h1><p><a href="http://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">JDK 11</a> 目前出现了4个JEP，计划于 2018 年 9 月发布。</p><ul><li><a href="http://openjdk.java.net/jeps/309" target="_blank" rel="noopener">JEP 309</a>: 动态类文件常量。</li><li><a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">JEP 318</a>: 低开销垃圾收集器 Epsilon。</li><li><a href="http://openjdk.java.net/jeps/320" target="_blank" rel="noopener">JEP 320</a>: 移除 Java EE 和 CORBA 模块。</li><li><a href="http://openjdk.java.net/jeps/323" target="_blank" rel="noopener">JEP 323</a>: Lambda 参数的本地变量语法。</li></ul><h1 id="JDK-10"><a href="#JDK-10" class="headerlink" title="JDK 10"></a>JDK 10</h1><p><a href="http://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">JDK 10</a> 按计划将于2018年3月20日发布。新特性有：</p><ul><li><a href="http://openjdk.java.net/jeps/286" target="_blank" rel="noopener">JEP 286</a>: 局部变量的类型推导。该特性在社区讨论了很久并做了调查，可查看 JEP 286 调查结果。</li><li><a href="http://openjdk.java.net/jeps/296" target="_blank" rel="noopener">JEP 296</a>: 将 JDK 的多个代码仓库合并到一个储存库中。</li><li><a href="http://openjdk.java.net/jeps/304" target="_blank" rel="noopener">JEP 304</a>: 垃圾收集器接口。通过引入一个干净的垃圾收集器（GC）接口，改善不同垃圾收集器的源码隔离性。</li><li><a href="http://openjdk.java.net/jeps/307" target="_blank" rel="noopener">JEP 307</a>: 向 G1 引入并行 Full GC。</li><li><a href="http://openjdk.java.net/jeps/310" target="_blank" rel="noopener">JEP 310</a>: 应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中。</li><li><a href="http://openjdk.java.net/jeps/312" target="_blank" rel="noopener">JEP 312</a>: 线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程。</li><li><a href="http://openjdk.java.net/jeps/313" target="_blank" rel="noopener">JEP 313</a>: 移除 Native-Header Generation Tool (javah)</li><li><a href="http://openjdk.java.net/jeps/314" target="_blank" rel="noopener">JEP 314</a>: 额外的 Unicode 语言标签扩展。包括：cu (货币类型)、fw (每周第一天为星期几)、rg (区域覆盖)、tz (时区) 等。</li><li><a href="http://openjdk.java.net/jeps/316" target="_blank" rel="noopener">JEP 316</a>: 在备用内存设备上分配堆内存。允许 HotSpot 虚拟机在备用内存设备上分配 Java 对象堆。</li><li><a href="http://openjdk.java.net/jeps/317" target="_blank" rel="noopener">JEP 317</a>: 基于 Java 的 JIT 编译器（试验版本）。</li><li><a href="http://openjdk.java.net/jeps/319" target="_blank" rel="noopener">JEP 319</a>: 根证书。开源 Java SE Root CA 程序中的根证书。</li><li><a href="http://openjdk.java.net/jeps/322" target="_blank" rel="noopener">JEP 322</a>: 基于时间的版本发布模式。“Feature releases” 版本将包含新特性，“Update releases” 版本仅修复 Bug 。</li></ul><h1 id="JDK-9"><a href="#JDK-9" class="headerlink" title="JDK 9"></a>JDK 9</h1><p><a href="http://openjdk.java.net/projects/jdk9/" target="_blank" rel="noopener">JDK 9</a> 于2017年9月21日发布。新特性有：</p><ul><li>模块化 —— Jigsaw</li><li>交互式命令行 —— JShell</li><li>默认的垃圾回收器 —— G1</li><li>进程操作改进</li><li>竞争锁的性能优化</li><li>分段代码缓存</li><li>优化字符串占用空间</li></ul><p>这个版本中最引人注目的时候模块化，通过这个工作，可以构建更小的运行时环境，只需要包括Java平台中任务依赖的部分。这可以更好地适应云端的开发。</p><p>具体的特性包括：</p><ul><li><a href="http://openjdk.java.net/jeps/102" target="_blank" rel="noopener">JEP 102</a>: 改善了控制和管理操作系统进程的 API。</li><li><a href="http://openjdk.java.net/jeps/110" target="_blank" rel="noopener">JEP 110</a>: 定义了一个新的 Http 客户端 API，它实现了 <code>HTTP/2</code> 和 <code>WebSocket</code>，并且可以替代遗留的 <code>HttpURLConnection</code> API。该 API 将会以一个 incubator 模块的形式进行交付。</li><li><a href="http://openjdk.java.net/jeps/143" target="_blank" rel="noopener">JEP 143</a>: 提高竞争 Java 对象的监视性能。</li><li><a href="http://openjdk.java.net/jeps/158" target="_blank" rel="noopener">JEP 158</a>: 统一 JVM 的日志。</li><li><a href="http://openjdk.java.net/jeps/165" target="_blank" rel="noopener">JEP 165</a>: 通过支持运行时管理来增加对 JVM 编译器的管理。</li><li><a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193</a>: 对变量处理的改进。</li><li><a href="http://openjdk.java.net/jeps/197" target="_blank" rel="noopener">JEP 197</a>: 将代码缓存划分成不同的段。</li><li><a href="http://openjdk.java.net/jeps/200" target="_blank" rel="noopener">JEP 200</a>: 采用 Java 平台模块化系统（Java Platform Module System，JPMS）对JDK进行模块化。</li><li><a href="http://openjdk.java.net/jeps/201" target="_blank" rel="noopener">JEP 201</a>: 源代码模块化。</li><li><a href="http://openjdk.java.net/jeps/211" target="_blank" rel="noopener">JEP 211</a>: 在 import 语句中 省略 <code>deprecation</code> 的警告。</li><li><a href="http://openjdk.java.net/jeps/212" target="_blank" rel="noopener">JEP 212</a>: 解决 lint 和 doclint 警告。</li><li><a href="http://openjdk.java.net/jeps/213" target="_blank" rel="noopener">JEP 213</a>: Project Coin 的改变</li><li><a href="http://openjdk.java.net/jeps/214" target="_blank" rel="noopener">JEP 214</a>: 移除 JDK 8 中 GC 组合器的废弃说明。</li><li><a href="http://openjdk.java.net/jeps/215" target="_blank" rel="noopener">JEP 215</a>: 在 javac 中实现了一个新的类型检测策略。</li><li><a href="http://openjdk.java.net/jeps/216" target="_blank" rel="noopener">JEP 216</a>: 正确地处理导入声明。</li><li><a href="http://openjdk.java.net/jeps/217" target="_blank" rel="noopener">JEP 217</a>: 注解流水线 2.0。</li><li><a href="http://openjdk.java.net/jeps/219" target="_blank" rel="noopener">JEP 219</a>: 定义了数据传输层安全（Datagram Transport Layer Security, DTLS）API。</li><li><a href="http://openjdk.java.net/jeps/220" target="_blank" rel="noopener">JEP 220</a>: 模块化运行时镜像。</li><li><a href="http://openjdk.java.net/jeps/221" target="_blank" rel="noopener">JEP 221</a>: 简化 <code>Doclet</code> API。</li><li><a href="http://openjdk.java.net/jeps/222" target="_blank" rel="noopener">JEP 222</a>: jshell - Java 中的交互式命令行。</li><li><a href="http://openjdk.java.net/jeps/223" target="_blank" rel="noopener">JEP 223</a>: 新的版本字符串模式。</li><li><a href="http://openjdk.java.net/jeps/224" target="_blank" rel="noopener">JEP 224</a>: 增强了 javadoc 工具来生成 HTML5 标记。</li><li><a href="http://openjdk.java.net/jeps/225" target="_blank" rel="noopener">JEP 225</a>: 增加了 javadoc 搜索。</li><li><a href="http://openjdk.java.net/jeps/226" target="_blank" rel="noopener">JEP 226</a>: UTF-8 属性文件资源的Bundle相关变化。</li><li><a href="http://openjdk.java.net/jeps/227" target="_blank" rel="noopener">JEP 227</a>: Unicode 7.0。</li><li><a href="http://openjdk.java.net/jeps/228" target="_blank" rel="noopener">JEP 228</a>: 增加更多可诊断的命令。</li><li><a href="http://openjdk.java.net/jeps/229" target="_blank" rel="noopener">JEP 229</a>: 将默认的秘钥库从 JKS 替换为 PKCS12。</li><li><a href="http://openjdk.java.net/jeps/231" target="_blank" rel="noopener">JEP 231</a>: 移除运行时 JRE 版本选择。</li><li><a href="http://openjdk.java.net/jeps/232" target="_blank" rel="noopener">JEP 232</a>: 增强了安全相关应用的性能。</li><li><a href="http://openjdk.java.net/jeps/233" target="_blank" rel="noopener">JEP 233</a>: 开发了一个工具来自动测试运行时编译器。</li><li><a href="http://openjdk.java.net/jeps/235" target="_blank" rel="noopener">JEP 235</a>: 增加关于 javac 生成类文件属性的 测试。</li><li><a href="http://openjdk.java.net/jeps/236" target="_blank" rel="noopener">JEP 236</a>: 定义了解析 API 来支持 Nashorn 的 ECMAScript 抽象语法树。</li><li><a href="http://openjdk.java.net/jeps/237" target="_blank" rel="noopener">JEP 237</a>: Linux/AArch64 端口相关。</li><li><a href="http://openjdk.java.net/jeps/238" target="_blank" rel="noopener">JEP 238</a>: 多版本 JAR 文件。</li><li><a href="http://openjdk.java.net/jeps/240" target="_blank" rel="noopener">JEP 240</a>: 移除 JVM 的 TI hprof 客户端。</li><li><a href="http://openjdk.java.net/jeps/241" target="_blank" rel="noopener">JEP 241</a>: 移除 jhat 工具。</li><li><a href="http://openjdk.java.net/jeps/243" target="_blank" rel="noopener">JEP 243</a>: 提供 Java 语言级的 JVM 编译接口。</li><li><a href="http://openjdk.java.net/jeps/244" target="_blank" rel="noopener">JEP 244</a>: TLS 应用层协议协商。</li><li><a href="http://openjdk.java.net/jeps/245" target="_blank" rel="noopener">JEP 245</a>: 验证 JVM 命令行标志参数。</li><li><a href="http://openjdk.java.net/jeps/246" target="_blank" rel="noopener">JEP 246</a>: 利用 CPU 指令提升 GHASH 和 RSAd 的性能。</li><li><a href="http://openjdk.java.net/jeps/247" target="_blank" rel="noopener">JEP 247</a>: 对老平台版本的编译支持。</li><li><a href="http://openjdk.java.net/jeps/248" target="_blank" rel="noopener">JEP 248</a>: G1 作为默认的垃圾回收器。</li><li><a href="http://openjdk.java.net/jeps/249" target="_blank" rel="noopener">JEP 249</a>: 基于 TLS 实现 OCSP Stapling。</li><li><a href="http://openjdk.java.net/jeps/250" target="_blank" rel="noopener">JEP 250</a>: 在类数据分享（CDS）归档中存储 interned 字符串。</li><li><a href="http://openjdk.java.net/jeps/251" target="_blank" rel="noopener">JEP 251</a>: 多方案镜像。</li><li><a href="http://openjdk.java.net/jeps/252" target="_blank" rel="noopener">JEP 252</a>: 默认使用 CLDR Locale Data。</li><li><a href="http://openjdk.java.net/jeps/253" target="_blank" rel="noopener">JEP 253</a>: 为 JavaFX UI 控制 和 CSS API 的模块化做准备。</li><li><a href="http://openjdk.java.net/jeps/254" target="_blank" rel="noopener">JEP 254</a>: 采用一个空间更加高效的 String 内部表示。</li><li><a href="http://openjdk.java.net/jeps/255" target="_blank" rel="noopener">JEP 255</a>: 合并 Xerces 2.11.0 中的更新。</li><li><a href="http://openjdk.java.net/jeps/256" target="_blank" rel="noopener">JEP 256</a>: BeanInfo 注解调整。</li><li><a href="http://openjdk.java.net/jeps/257" target="_blank" rel="noopener">JEP 257</a>: 更新 JavaFX/Media 中 GStreamer 的版本。</li><li><a href="http://openjdk.java.net/jeps/258" target="_blank" rel="noopener">JEP 258</a>: 使用 HarfBuzz 作为字体布局引擎。</li><li><a href="http://openjdk.java.net/jeps/259" target="_blank" rel="noopener">JEP 259</a>: 定义了一个高效标准的 Stack-Walking API。</li><li><a href="http://openjdk.java.net/jeps/260" target="_blank" rel="noopener">JEP 260</a>: 封装大部分的内部 API。</li><li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">JEP 261</a>: 实现模块化系统。</li><li><a href="http://openjdk.java.net/jeps/262" target="_blank" rel="noopener">JEP 262</a>: 支持 TIFF 图像 I/O。</li><li><a href="http://openjdk.java.net/jeps/263" target="_blank" rel="noopener">JEP 263</a>: 实现 Windows 和 Linux 高分辨率图像接口。</li><li><a href="http://openjdk.java.net/jeps/264" target="_blank" rel="noopener">JEP 264</a>: 平台日志 API 和 服务。</li><li><a href="http://openjdk.java.net/jeps/265" target="_blank" rel="noopener">JEP 265</a>: Java 2D 使用 Marlin Graphics Renderer。</li><li><a href="http://openjdk.java.net/jeps/266" target="_blank" rel="noopener">JEP 266</a>: 并发相关的一些更新。</li><li><a href="http://openjdk.java.net/jeps/267" target="_blank" rel="noopener">JEP 267</a>: 支持 Unicode 8.0。</li><li><a href="http://openjdk.java.net/jeps/268" target="_blank" rel="noopener">JEP 268</a>: 支持 XML 目录。</li><li><a href="http://openjdk.java.net/jeps/269" target="_blank" rel="noopener">JEP 269</a>: 增加一些集合类创建的工厂方法。</li><li><a href="http://openjdk.java.net/jeps/270" target="_blank" rel="noopener">JEP 270</a>: 为临界区预留栈的某些区域。</li><li><a href="http://openjdk.java.net/jeps/271" target="_blank" rel="noopener">JEP 271</a>: 统一 GC 日志。</li><li><a href="http://openjdk.java.net/jeps/272" target="_blank" rel="noopener">JEP 272</a>: 增加特定平台的桌面特性。</li><li><a href="http://openjdk.java.net/jeps/273" target="_blank" rel="noopener">JEP 273</a>: Deterministic Random Bit Generator (DRBG) 的实现。</li><li><a href="http://openjdk.java.net/jeps/274" target="_blank" rel="noopener">JEP 274</a>: 增强方法处理器。</li><li><a href="http://openjdk.java.net/jeps/275" target="_blank" rel="noopener">JEP 275</a>: Java 应用模块化打包。</li><li><a href="http://openjdk.java.net/jeps/276" target="_blank" rel="noopener">JEP 276</a>: 语言定义对象模型的动态链接。</li><li><a href="http://openjdk.java.net/jeps/277" target="_blank" rel="noopener">JEP 277</a>: 改善 Deprecation。</li><li><a href="http://openjdk.java.net/jeps/278" target="_blank" rel="noopener">JEP 278</a>: 为 G1 中的巨大对象增加测试。</li><li><a href="http://openjdk.java.net/jeps/279" target="_blank" rel="noopener">JEP 279</a>: 改进测试故障排除。</li><li><a href="http://openjdk.java.net/jeps/280" target="_blank" rel="noopener">JEP 280</a>: 指示字符串串联。</li><li><a href="http://openjdk.java.net/jeps/281" target="_blank" rel="noopener">JEP 281</a>: HotSpot C++ 单元测试框架。</li><li><a href="http://openjdk.java.net/jeps/282" target="_blank" rel="noopener">JEP 282</a>: Java连接器 jlink。</li><li><a href="http://openjdk.java.net/jeps/283" target="_blank" rel="noopener">JEP 283</a>: 在 Linux 上支持 GTK 3。</li><li><a href="http://openjdk.java.net/jeps/284" target="_blank" rel="noopener">JEP 284</a>: 新的 HotSpot 构建系统。</li><li><a href="http://openjdk.java.net/jeps/285" target="_blank" rel="noopener">JEP 285</a>: 自旋等待提示。</li><li><a href="http://openjdk.java.net/jeps/287" target="_blank" rel="noopener">JEP 287</a>: 实现 SHA-3 Hash 算法。</li><li><a href="http://openjdk.java.net/jeps/288" target="_blank" rel="noopener">JEP 288</a>: 禁止 SHA-1 验证。</li><li><a href="http://openjdk.java.net/jeps/289" target="_blank" rel="noopener">JEP 289</a>: 废弃 Applet API。</li><li><a href="http://openjdk.java.net/jeps/290" target="_blank" rel="noopener">JEP 290</a>: 过滤输入的序列化数据。</li><li><a href="http://openjdk.java.net/jeps/291" target="_blank" rel="noopener">JEP 291</a>: 废弃 Concurrent Mark Sweep (CMS) 垃圾收集器。</li><li><a href="http://openjdk.java.net/jeps/292" target="_blank" rel="noopener">JEP 292</a>: 在 Nashorn 中支持 ECMAScript 6 特征。</li><li><a href="http://openjdk.java.net/jeps/294" target="_blank" rel="noopener">JEP 294</a>: Linux/s390x 端口。</li><li><a href="http://openjdk.java.net/jeps/295" target="_blank" rel="noopener">JEP 295</a>: 提前编译。</li><li><a href="http://openjdk.java.net/jeps/297" target="_blank" rel="noopener">JEP 297</a>: 统一 arm32/arm64 端口。</li><li><a href="http://openjdk.java.net/jeps/298" target="_blank" rel="noopener">JEP 298</a>: 移除过时的例子。</li><li><a href="http://openjdk.java.net/jeps/299" target="_blank" rel="noopener">JEP 299</a>: 重新组织文档。 </li></ul><h1 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h1><p><a href="http://openjdk.java.net/projects/jdk8/" target="_blank" rel="noopener">JDK 8</a> 于2014年3月14号发布。从 Java 8 开始开发代号已经弃用了。新特性有:</p><ul><li>Lambda 表达式</li><li>Pipelines 和 Streams</li><li>Date 和 Time API</li><li>Default 方法</li><li>Type 注解</li><li>Nashhorn JavaScript 引擎</li><li>并发计数器</li><li>Parallel 操作</li><li>移除 PermGen Error</li><li>TLS SNI</li></ul><p>第三个有里程碑意义的 Java 版本。其中最引人注目的便是 Lambda 表达式了，从此 Java 语言原生提供了函数式编程能力。Java 8 更加适应海量云计算的需要。</p><p>具体的特性包括：</p><ul><li><a href="http://openjdk.java.net/jeps/117" target="_blank" rel="noopener">JEP 117</a>: 移除注解处理工具（Annotation-Processing Tool，apt）。</li><li><a href="http://openjdk.java.net/jeps/124" target="_blank" rel="noopener">JEP 124</a>: 增强证书撤销检查 API。</li><li><a href="http://openjdk.java.net/jeps/130" target="_blank" rel="noopener">JEP 130</a>: 实现 SHA-224 消息摘要算法。</li><li><a href="http://openjdk.java.net/jeps/131" target="_blank" rel="noopener">JEP 131</a>: 在 64-bit Windows 中支持 PKCS#11。</li><li><a href="http://openjdk.java.net/jeps/112" target="_blank" rel="noopener">JEP 112</a>: Charset 实现改善。</li><li><a href="http://openjdk.java.net/jeps/129" target="_blank" rel="noopener">JEP 129</a>: 实现 NSA Suite B 加密算法。</li><li><a href="http://openjdk.java.net/jeps/105" target="_blank" rel="noopener">JEP 105</a>: DocTree API。</li><li><a href="http://openjdk.java.net/jeps/106" target="_blank" rel="noopener">JEP 106</a>: 扩展 <code>javax.tools</code> API 来支持 javadoc 的访问。</li><li><a href="http://openjdk.java.net/jeps/113" target="_blank" rel="noopener">JEP 113</a>: 在 JDK 的 Kerberos 5 中添加 MS-SFU 扩展。</li><li><a href="http://openjdk.java.net/jeps/114" target="_blank" rel="noopener">JEP 114</a>: TLS Server Name Indication (SNI) 扩展。</li><li><a href="http://openjdk.java.net/jeps/121" target="_blank" rel="noopener">JEP 121</a>: 提供更强的 Password-Based-Encryption (PBE) 算法实现。</li><li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122</a>: 移除永久带（Permanent Generation）。</li><li><a href="http://openjdk.java.net/jeps/127" target="_blank" rel="noopener">JEP 127</a>: 改善 Locale Data Packaging，并且采用 Unicode CLDR Data。</li><li><a href="http://openjdk.java.net/jeps/128" target="_blank" rel="noopener">JEP 128</a>: Unicode BCP 47 本地匹配。</li><li><a href="http://openjdk.java.net/jeps/133" target="_blank" rel="noopener">JEP 133</a>: 支持 Unicode 6.2。</li><li><a href="http://openjdk.java.net/jeps/136" target="_blank" rel="noopener">JEP 136</a>: 增强错误验证。</li><li><a href="http://openjdk.java.net/jeps/153" target="_blank" rel="noopener">JEP 153</a>: 启动 JavaFX 应用。</li><li><a href="http://openjdk.java.net/jeps/177" target="_blank" rel="noopener">JEP 177</a>: 优化 <code>java.text.DecimalFormat.format</code>。</li><li><a href="http://openjdk.java.net/jeps/103" target="_blank" rel="noopener">JEP 103</a>: 并行数组排序。</li><li><a href="http://openjdk.java.net/jeps/135" target="_blank" rel="noopener">JEP 135</a>: Base64 编码和解码。</li><li><a href="http://openjdk.java.net/jeps/138" target="_blank" rel="noopener">JEP 138</a>: 基于 Autoconf 的自动构建系统。</li><li><a href="http://openjdk.java.net/jeps/139" target="_blank" rel="noopener">JEP 139</a>: 增强 javac 来提高构建速度。</li><li><a href="http://openjdk.java.net/jeps/142" target="_blank" rel="noopener">JEP 142</a>: 减少对于特定域的高速缓存的争夺。</li><li><a href="http://openjdk.java.net/jeps/147" target="_blank" rel="noopener">JEP 147</a>: 减少类元数据占用。</li><li><a href="http://openjdk.java.net/jeps/148" target="_blank" rel="noopener">JEP 148</a>: 支持小虚拟机（不超过3M）的创建。</li><li><a href="http://openjdk.java.net/jeps/149" target="_blank" rel="noopener">JEP 149</a>: 减少核心库的内存使用。</li><li><a href="http://openjdk.java.net/jeps/150" target="_blank" rel="noopener">JEP 150</a>: 新的 Date 和 Time API。</li><li><a href="http://openjdk.java.net/jeps/160" target="_blank" rel="noopener">JEP 160</a>: lambda 函数表达式。</li><li><a href="http://openjdk.java.net/jeps/164" target="_blank" rel="noopener">JEP 164</a>: 利用 CPU 指令进行 AES 加密。</li><li><a href="http://openjdk.java.net/jeps/166" target="_blank" rel="noopener">JEP 166</a>: 针对JKS、JCEKS、PKCS12秘钥存储的修改。</li><li><a href="http://openjdk.java.net/jeps/170" target="_blank" rel="noopener">JEP 170</a>: JDBC 4.2。</li><li><a href="http://openjdk.java.net/jeps/172" target="_blank" rel="noopener">JEP 172</a>: DocLint。</li><li><a href="http://openjdk.java.net/jeps/173" target="_blank" rel="noopener">JEP 173</a>: 放弃一些很少使用的 GC 组合。</li><li><a href="http://openjdk.java.net/jeps/101" target="_blank" rel="noopener">JEP 101</a>: 泛华目标类型接口。</li><li><a href="http://openjdk.java.net/jeps/104" target="_blank" rel="noopener">JEP 104</a>: 在 Java 类型上加注解。</li><li><a href="http://openjdk.java.net/jeps/107" target="_blank" rel="noopener">JEP 107</a>: 增加集合的批量数据操作。</li><li><a href="http://openjdk.java.net/jeps/109" target="_blank" rel="noopener">JEP 109</a>: 在核心库中增加 Lambda 表达式。</li><li><a href="http://openjdk.java.net/jeps/115" target="_blank" rel="noopener">JEP 115</a>: 认证加密的密码套件。</li><li><a href="http://openjdk.java.net/jeps/118" target="_blank" rel="noopener">JEP 118</a>: 在运行时访问参数名称。</li><li><a href="http://openjdk.java.net/jeps/119" target="_blank" rel="noopener">JEP 119</a>: 通过反射实现  <code>javax.lang.model.*</code> API。</li><li><a href="http://openjdk.java.net/jeps/120" target="_blank" rel="noopener">JEP 120</a>: 重复注解。</li><li><a href="http://openjdk.java.net/jeps/123" target="_blank" rel="noopener">JEP 123</a>: 可配置的安全随机数生成。</li><li><a href="http://openjdk.java.net/jeps/126" target="_blank" rel="noopener">JEP 126</a>: lambda 表达式和虚拟扩展方法。</li><li><a href="http://openjdk.java.net/jeps/140" target="_blank" rel="noopener">JEP 140</a>: 限制的 doPrivileged。</li><li><a href="http://openjdk.java.net/jeps/155" target="_blank" rel="noopener">JEP 155</a>: 并发库更新。</li><li><a href="http://openjdk.java.net/jeps/161" target="_blank" rel="noopener">JEP 161</a>: 紧凑版本。</li><li><a href="http://openjdk.java.net/jeps/162" target="_blank" rel="noopener">JEP 162</a>: 为模块化做准备。</li><li><a href="http://openjdk.java.net/jeps/171" target="_blank" rel="noopener">JEP 171</a>: 在 <code>sun.misc.Unsafe</code> 中增加三个内存排序相关的指令。</li><li><a href="http://openjdk.java.net/jeps/174" target="_blank" rel="noopener">JEP 174</a>: Nashorn JavaScript 引擎。</li><li><a href="http://openjdk.java.net/jeps/176" target="_blank" rel="noopener">JEP 176</a>: 提供调用者敏感的检测机制。</li><li><a href="http://openjdk.java.net/jeps/178" target="_blank" rel="noopener">JEP 178</a>: 静态链接的 jni 库。</li><li><a href="http://openjdk.java.net/jeps/179" target="_blank" rel="noopener">JEP 179</a>: JDK API 的文档的支持和稳定。</li><li><a href="http://openjdk.java.net/jeps/180" target="_blank" rel="noopener">JEP 180</a>: 对于频繁冲突的 HashMap 使用平衡树。</li><li><a href="http://openjdk.java.net/jeps/184" target="_blank" rel="noopener">JEP 184</a>: HTTP URL的权限。</li><li><a href="http://openjdk.java.net/jeps/" target="_blank" rel="noopener">JEP 185</a>: 限制外部 XML 资源的获取。</li></ul><h1 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h1><p>开发代号是 Dolphin（海豚），于2011年7月28日发行。新特性有：</p><ul><li><code>switch</code> 语句块中允许以字符串作为分支条件；</li><li>在创建泛型对象时应用类型推断；</li><li>在一个语句块中捕获多种异常；</li><li>支持动态语言；</li><li>支持 <code>try-with-resources</code>；</li><li>引入 Java NIO.2 开发包；</li><li>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</li><li>钻石型语法；</li><li><code>null</code> 值的自动处理。</li></ul><p>这个版本中的主要的特性是 NIO2 和 Fork/Join 并发包，Java 虚拟机的稳定性真正做到的工业级，成为一个计算平台而服务于全世界。</p><h1 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h1><p>开发代号为 Mustang（野马），于2006年12月11日发行。新特性有：</p><ul><li>支持脚本语言；</li><li>引入 JDBC 4.0 API；</li><li>引入 Java Compiler API；</li><li>可插拔注解；</li><li>增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos 和 LDAP(Lightweight Directory Access Protocol) 的支持；</li><li>继承 Web Services；</li><li>做了很多优化。</li></ul><p>这个语言语法改进不多，但在虚拟机内部做了大量的改进，成为一个相当成熟稳定的版本，时至今日国内的很多公司依然以 Java6 作为主要 Java 开发版本来使用。</p><p>同年 Sun 公司做出一个伟大的决定，将 Java 开源。OpenJDK 从 Sun JDK 1.7 版本分支出去，成为今天 OpenJDK 的基础。</p><h1 id="JDK-5"><a href="#JDK-5" class="headerlink" title="JDK 5"></a>JDK 5</h1><p>开发代号为Tiger（老虎），于2004年9月30日发行。新特性包有:</p><ul><li>引入泛型；</li><li>增强循环，可以使用迭代方式；</li><li>自动装箱与自动拆箱；</li><li>类型安全的枚举；</li><li>可变参数；</li><li>静态引入；</li><li>元数据（注解）；</li><li>引入 Instrumentation。</li></ul><p>Sun 不再采用 J2SE, J2EE 这种命名方式，而使用 Java SE 5, Java EE 5 这样的名称。</p><p>Java 5 是第二个里程碑式的版本。Java 语言语法发生很大的变化，如注解 (Annotation)，装箱 (Autoboxing)，泛型 (Generic)，枚举 (Enum)，foreach 等被加入，提供了 java.util.concurrent 并发包。</p><p>Java 5 对于 Java 语言的推动是巨大的，特别是注解的加入，使得语言定义灵活了很多，程序员可以写出更加符合领域定义的描述性程序。</p><h1 id="JDK-1-4"><a href="#JDK-1-4" class="headerlink" title="JDK 1.4"></a>JDK 1.4</h1><p>开发代号为 Merlin（隼），于2004年2月06日发行（首次在JCP下发行）。新特性有:</p><ul><li>XML 处理；</li><li>Java 打印服务；</li><li>引入 Logging API；</li><li>引入 Java Web Start；</li><li>引入 JDBC 3.0 API；</li><li>引入断言；</li><li>引入 Preferences API；</li><li>引入链式异常处理；</li><li>支持 IPv6；</li><li>支持正则表达式；</li><li>引入 Image I/O slot machine API。</li></ul><p>Java 语言真正走向成熟，提供了非常完备的语言特性，如 NIO，正则表达式，XML 处理器等。</p><p>同年微软的.NET 框架发布，两者开始了为期十几年的暗自竞争。从语言特性上来说，.NET 后发先至，一直处于优势。但 Java 依赖良好的开发者生态，绝大多数大型软件公司的使用者众多和不断贡献，以及对 Linux 操作系统良好的支持，渐渐的在服务器端获得优势地位。</p><h1 id="JDK-1-3"><a href="#JDK-1-3" class="headerlink" title="JDK 1.3"></a>JDK 1.3</h1><p>开发代号为 Kestrel（红隼），于2000年5月08日发行。新特性有：</p><ul><li>引入Java Sound API；</li><li>jar 文件索引；</li><li>对 Java 的各个方面都做了大量优化和增强。</li></ul><p>J2EE 中的 Servlet 规范获得了极大的成功，伴随着互联网的兴起，和浏览器直接通过 HTTP 协议交互的 Servlet，和众多的 MVC 框架，成为 Web1.0 的网红。</p><h1 id="JDK-1-2"><a href="#JDK-1-2" class="headerlink" title="JDK 1.2"></a>JDK 1.2</h1><p>开发代号为 Playground（操场），于1998年12月8日发行。新特性有：</p><ul><li>引入集合（Collection）框架；</li><li>对字符串常量做内存映射；</li><li>引入 JIT（Just In Time） 编译器；</li><li>引入对打包的 Java 文件进行数字签名；</li><li>引入控制授权访问系统资源的策略工具；</li><li>引入 JFC（Java Foundation Classes），包括 Swing 1.0、拖放和 Java 2D 类库；</li><li>引入 Java 插件；</li><li>在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；</li><li>在 Applet 中添加声音支持。</li></ul><p>Java 第一个里程碑式的版本。JIT（Just in time）编译器技术，使得语言的可迁移性和执行效率达到最优的平衡，同时 Collections 集合类设计优良，在企业应用开发中迅速得到了广泛使用。</p><p>Sun 公司把 Java 技术体系分成三个方向，分别是 J2SE（面向桌面和通用应用开发），J2EE（面向企业级应用开发），J2ME（面向移动终端开发）。这个分类影响非常久远，体现出主流语言设计者的思想：针对于不同的应用领域，在形态，API 集合等进行划分。</p><h1 id="JDK-1-1"><a href="#JDK-1-1" class="headerlink" title="JDK 1.1"></a>JDK 1.1</h1><p>于 1997年2月19日发行，新特性有：</p><ul><li>引入JDBC（Java Database Connectivity）；</li><li>支持内部类；</li><li>引入Java Bean；</li><li>引入RMI（Remote Method Invocation）；</li><li>引入反射（仅用于内省）。</li></ul><p>Java 语言的基本形态基本确定了，比如反射 (reflection), JavaBean, 接口和类的关系等等，一直到今天都保持一致。然而，Java 最初的一些目标，如在浏览器中执行 Applet，以及跨平台的图形界面 Awt 很快遭遇到负面的评价。</p><h1 id="JDK-1-0"><a href="#JDK-1-0" class="headerlink" title="JDK 1.0"></a>JDK 1.0</h1><p>开发代号为Oak（橡树），于1996年1月23发行。特点有：</p><ul><li>提供了一个解释执行的 Java 虚拟机；</li><li>Applet 能在 Mozilla 浏览器中运行。</li></ul><p>Java 的 Applet 能在 Mozilla 浏览器中运行，被看作是未来的互联网语言。</p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>Java 语言源于 1991 年 Sun 公司 James Gosling 领导的的 Ork 项目，1995 年 Sun 公司正式起名为 Java，并提出“Write once, Run anywhere”的口号。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Java版本的更新历史，主要是对以下文章的结合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/projects/jdk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《openjdk 文档》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/u010297957/article/details/50915631&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Java - JCP、JSR等名词介绍》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/rese-t/p/7823378.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《从java1到java9每个版本都有什么新特性？》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/postnull/article/details/78068060?locationNum=2&amp;amp;fps=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Java 9正式发布》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/93123/jdk10-release-candidate-phase&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JDK 10 本周将进入候选发布阶段，新特性抢先看》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/is-java-out-of-date&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Java 老矣，尚能饭否？》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章 Github 地址：&lt;a href=&quot;https://github.com/mindawei/JDKHistory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JDKHistory&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mindawei.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="JDK" scheme="http://mindawei.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>HTTP变化介绍</title>
    <link href="http://mindawei.github.io/2018/03/13/HTTP%E5%8F%98%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
    <id>http://mindawei.github.io/2018/03/13/HTTP变化介绍/</id>
    <published>2018-03-13T05:30:46.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 HTTP 变化的介绍，是对以下资料的摘录：</p><ul><li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">《Hypertext Transfer Protocol》</a></li><li><a href="https://www.nihaoshijie.com.cn/index.php/archives/630/" target="_blank" rel="noopener">《HTTP,HTTP2.0,SPDY,HTTPS看这篇就够了》</a></li><li><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">《HTTP/2.0 相比1.0有哪些重大改进？》</a></li><li>本科课件</li></ul><a id="more"></a><h1 id="HTTP-概览"><a href="#HTTP-概览" class="headerlink" title="HTTP 概览"></a>HTTP 概览</h1><p>HTTP 是 Hypertext Transfer Protocol 的简称，中文是超文本传输协议。它是一个应用层协议，可以支持分布式的、协作的、具有富文本信息的系统。（定义来自<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">维基百科</a>）</p><p>HTTP 的发展过程如下所示：</p><ul><li><p>1989年，HTTP 起源于 Tim Berners-Lee 在 CERN 的工作。HTTP 的标准化发展过程是由因特网工程任务组（Internet Engineering Task Force，IETF）和万维网联盟（World Wide Web Consortium，W3C）共同推进的，主要是一系列的 RFC 标准（Requests for Comments，RFCs）。</p></li><li><p>1991年，HTTP 第一个标准文档 <a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html" target="_blank" rel="noopener">HTTP V0.9</a> 发布。</p></li><li><p>1996年，Dave Raggett 领导了 HTTP 工作组（HTTP Working Group，HTTP WG）进一步完善了 HTTP 的功能，在 <a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">RFC 1945</a> 中发布了 HTTP V1.0。</p></li><li><p>1997年，一个使用更加广泛的版本 HTTP/1.1 在 <a href="https://tools.ietf.org/html/rfc2068" target="_blank" rel="noopener">RFC 2068</a> 中被提出。1999年发布的 <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC 2616</a> 对上一个版本进行了更新。2014年又发布了6个规范进行了一步的升级，具体包括：</p><blockquote><p><a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener">RFC 7230</a>, HTTP/1.1: Message Syntax and Routing（消息语法和路由）<br><a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">RFC 7231</a>, HTTP/1.1: Semantics and Content（语义和内容）<br><a href="https://tools.ietf.org/html/rfc7232" target="_blank" rel="noopener">RFC 7232</a>, HTTP/1.1: Conditional Requests（条件请求）<br><a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">RFC 7233</a>, HTTP/1.1: Range Requests（范围请求）<br><a href="https://tools.ietf.org/html/rfc7234" target="_blank" rel="noopener">RFC 7234</a>, HTTP/1.1: Caching（缓存）<br><a href="https://tools.ietf.org/html/rfc7235" target="_blank" rel="noopener">RFC 7235</a>, HTTP/1.1: Authentication（认证）</p></blockquote></li><li><p>2015年，一个新的标准 <a href="http://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">HTTP/2</a> 在 <a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">RFC 7540</a> 中发布，<a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="noopener">它建立在 TLS 层上，使用 ALPN 进行扩展</a>，现在已经被很多 web 服务器和浏览器支持了。</p></li></ul><p><img src="/images/00025/01.png" alt="HTTP版本变化" title="HTTP版本变化"></p><h1 id="HTTP-基本优化"><a href="#HTTP-基本优化" class="headerlink" title="HTTP 基本优化"></a>HTTP 基本优化</h1><p>影响 HTTP 响应速度的因素主要有：<strong>带宽</strong>和<strong>延迟</strong>。由于<strong>带宽</strong>是外在环境，并且这些年带宽速度得到了极大提升，所以不再详细介绍。 而影响<strong>延迟</strong>的因素又包括：</p><ul><li><strong>浏览器阻塞</strong>（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。具体如下表所示（<a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/" target="_blank" rel="noopener">表格来源</a>）：</li></ul><table><thead><tr><th>浏览器</th><th>HTTP/1.1</th><th>HTTP/1.0</th></tr></thead><tbody><tr><td>IE 6,7</td><td>2</td><td>4</td></tr><tr><td>IE 8</td><td>6</td><td>6 </td></tr><tr><td>Firefox 2</td><td>2</td><td>8</td></tr><tr><td>Firefox 3</td><td>6</td><td>6</td></tr><tr><td>Safari 3,4</td><td>4</td><td>4</td></tr><tr><td>Chrome 1,2</td><td>6</td><td>？</td></tr><tr><td>Chrome 3</td><td>4</td><td>4</td></tr><tr><td>Chrome 4+</td><td>6</td><td>？</td></tr><tr><td>iPhone 2</td><td>4</td><td>？</td></tr><tr><td>iPhone 3</td><td>6</td><td>？</td></tr><tr><td>iPhone 4</td><td>4</td><td>？</td></tr><tr><td>Opera 9.63,10.00alpha</td><td>4</td><td>4</td></tr><tr><td>Opera 10.51+</td><td>8</td><td>？</td></tr></tbody></table><ul><li><strong>DNS 查询</strong>（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li><strong>建立连接</strong>（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和<a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start" target="_blank" rel="noopener">慢启动</a>。三次握手在高延迟的场景下影响较明显，<a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start" target="_blank" rel="noopener">慢启动</a>则对文件类大请求影响较大。<br><img src="/images/00025/02.png" alt="TCP的三次握手四次挥手" title="TCP的三次握手四次挥手"></li></ul><h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h1><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="noopener">HTTP 1.1</a> 在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP 1.1 也是当前使用最为广泛的 HTTP 协议。HTTP 1.0 的新特性有：</p><ul><li><strong>长连接</strong>。HTTP 1.1 支持长连接（PersistentConnection）和 请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP 1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP 1.0 每次请求都要创建连接的缺点。</li><li><strong>缓存处理</strong>。在 HTTP 1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，HTTP 1.1 则引入了更多的缓存控制策略，如：Entity tag、If-Unmodified-Since、If-Match、If-None-Match等，可以基于此提供更多的缓存控制策略。</li><li><strong>带宽优化及网络连接的使用</strong>。HTTP 1.0 中，存在一些浪费带宽的现象，如：客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP 1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由选择资源区域，便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>。在 HTTP 1.1 中新增了24个错误状态响应码，如：409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>。在 HTTP 1.0 中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP 1.1 的请求消息和响应消息都应支持Host头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li><li><strong>缓冲区指针</strong>。实现缓冲区指针允许客户和服务器的缺省缓冲区算法可以被调用或优化。* <strong>主机标题</strong>。HTTP 1.1 协议允许多重主机名与一个单独的IP地址相关联。这样就不用给一个驻留许多虚拟服务器的 Web 服务器配置多个IP地址了。这个主机标题可以用来确定请求应该被导向哪个虚拟服务器。</li><li><strong>PUT和DELETE选项</strong>。这些命令允许一个远程管理者通过使用一个标准的 Web 浏览器来记入或删除一些内容。</li><li><strong>HTTP重定向</strong>。当原始的主页不能访问或被删除时，这个特性允许一个管理者将一个用户重定向到一个备选的主页或 Web 站点。</li></ul><h1 id="HTTP-1-0-和-1-1-的一些问题"><a href="#HTTP-1-0-和-1-1-的一些问题" class="headerlink" title="HTTP 1.0 和 1.1 的一些问题"></a>HTTP 1.0 和 1.1 的一些问题</h1><ul><li>HTTP 1.x 在传输数据时，每次都需要重新建立连接，这增加了大量的延迟时间，在移动端更为突出。</li><li>HTTP 1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</li><li>HTTP 1.x 在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化。在移动端用户流量较大时，问题更为突出。</li><li>HTTP 1.x 虽然通过支持keep-alive来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后，还长时间地保持了不必要的连接。</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>为了解决传输的安全问题，Netscape 在1994年创建了 HTTPS ，并应用在浏览器中。最初，HTTPS 是与 SSL 一起使用的，后来 SSL 逐渐演变到 TLS （本质上两个是一个东西）。最新的 HTTPS 在2000年5月公布的RFC 2818正式确定下来。</p><p>简单来说，HTTPS 就是安全版的 HTTP，并且由于当今时代对安全性要求更高，Chrome 和 Firefox 都大力支持网站使用 HTTPS，苹果也在 IOS 10系统中强制 App 使用 HTTPS 来传输数据，由此可见 HTTPS 势在必行。</p><p><strong>HTTPS 与 HTTP 的一些区别</strong></p><ul><li>HTTPS 协议需要到 CA 申请证书。</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。可进行身份认证，比 HTTP 协议安全。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，HTTP 是80，HTTPS 是443。</li></ul><p>HTTPS 由于增加了 SSL 的握手过程，会有一定的性能损失。此外，由于有较多的秘钥算法计算，需要关注服务端的 CPU 压力。推荐一个PPT<a href="http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf" target="_blank" rel="noopener">《淘宝HTTPS探索》</a>。</p><h1 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h1><p>2012年 Google 提出了 <a href="https://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00" target="_blank" rel="noopener">SPDY</a> 的方案，大家才开始从正面看待和解决老版本 HTTP 协议本身的问题，SPDY 综合了 HTTPS 和 HTTP 两者的优点于一体，主要特点如下所示：</p><ul><li><strong>降低延迟</strong>。针对 HTTP 高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 stream 共享一个 TCP 连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级（request prioritization）</strong>。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。如:浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩</strong>。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于 HTTPS 的加密协议传输</strong>。大大提高了传输数据的可靠性。</li><li><strong>服务端推送（server push）</strong>。采用了 SPDY 的网页，例如：网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。</li></ul><p>SPDY 构成图如下所示：<br><img src="/images/00025/03.png" alt="SPDY构成" title="SPDY构成"></p><h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p><a href="http://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">HTTP 2.0</a> 可以说是 SPDY 的升级版（其实原本也是基于 SPDY 设计的）。但 HTTP2.0 跟 SPDY 仍有不同的地方，主要是：</p><ul><li>HTTP 2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS。</li><li>HTTP 2.0 消息头的压缩算法采用 <a href="https://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">HPACK</a>，而 SPDY 采用的是 <a href="https://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">DEFLATE</a>。</li></ul><p>HTTP 2.0 与 HTTP 1.0 的速度对比如下（<a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">演示网站</a>）：<br><img src="/images/00025/04.png" alt="速度对比" title="速度对比"></p><p>HTTP 2.0 的一些新的特性包括：</p><ul><li><strong>多路复用（MultiPlexing），即连接共享</strong>。 每一个 request 都是是用作连接共享机制的。一个 request 对应一个id，这样一个连接上可以有多个request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 归属到各自不同的服务端请求里面。多路复用原理图如下所示：<br><img src="/images/00025/05.png" alt="多路复用" title="多路复用"></li></ul><p><img src="/images/00025/06.jpg" alt="Http1.1和Http2的对比" title="Http1.1和Http2的对比"></p><ul><li><p><strong>新的二进制格式（Binary Format）</strong>，HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑 HTTP 2.0 的协议解析决定采用二进制格式，实现方便且健壮。实现关键之一就是在应用层（HTTP/2）和传输层（TCP 或 UDP）之间增加一个二进制分帧层。<br><img src="/images/00025/07.jpg" alt="二进制分帧" title="二进制分帧"></p></li><li><p><strong>Header 压缩</strong>。前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p></li><li><strong>服务端推送（server push）</strong>。同SPDY一样，HTTP 2.0 也具有 server push 功能。目前，有大多数网站已经启用 HTTP 2.0 了。</li></ul><p>更多关于 HTTP 2.0 资料如下：</p><ul><li><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/" target="_blank" rel="noopener">《HTTP2 奇妙日常》</a>。</li><li>HTTP 2.0 的<a href="https://http2.akamai.com/" target="_blank" rel="noopener">官方网站</a>。</li><li><a href="https://www.gitbook.com/book/ye11ow/http2-explained/details" target="_blank" rel="noopener">《HTTP2 讲解》</a>。</li><li><a href="https://www.mnot.net/talks/h2fe/" target="_blank" rel="noopener">《HTTP/2 for Front-End Developers》</a>。</li><li><a href="https://www.nginx.com/blog/7-tips-for-faster-http2-performance/" target="_blank" rel="noopener">《7 Tips for Faster HTTP/2 Performance》</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 HTTP 变化的介绍，是对以下资料的摘录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Hypertext Transfer Protocol》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nihaoshijie.com.cn/index.php/archives/630/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《HTTP,HTTP2.0,SPDY,HTTPS看这篇就够了》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/34074946&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《HTTP/2.0 相比1.0有哪些重大改进？》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本科课件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="http://mindawei.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://mindawei.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Http" scheme="http://mindawei.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>线程池的使用</title>
    <link href="http://mindawei.github.io/2018/03/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://mindawei.github.io/2018/03/04/线程池的使用/</id>
    <published>2018-03-04T15:30:46.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对 Java 中的线程池的使用进行学习。是对以下文章的摘录：</p><ul><li>JDK 源码</li><li>阿里编程规范插件提示</li></ul><a id="more"></a><h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><h2 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h2><p>Java 类库中任务执行的抽象接口是 <code>Executor</code>。这个接口使得任务提交和任务如何被执行（包括线程使用细节、调度等）得到了解耦。该接口如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @since 1.5</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> */</span><br><span class="line">public interface Executor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 在将来某个时刻执行任务（ command ）。这个任务可以通过这些方式执行：在一个新的线程中执行、</span><br><span class="line"> * 在一个缓存的线程中执行、在调用者线程中执行。具体取决于 Executor 的实现方式。</span><br><span class="line">     *</span><br><span class="line">     * @param command 需要运行的任务</span><br><span class="line">     * @throws RejectedExecutionException 如果执行器不接受任务，则抛出改异常。</span><br><span class="line">     * @throws NullPointerException 如果任务为 null</span><br><span class="line">     */</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用-Executor-执行任务"><a href="#使用-Executor-执行任务" class="headerlink" title="使用 Executor 执行任务"></a>使用 Executor 执行任务</h2><p><code>Executor</code> 经常被用来代替显示地创建线程。<br>自己手工创建线程执行（不建议）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new RunnableTask()).start()</span><br></pre></td></tr></table></figure></p><p>使用 <code>Executor</code> 执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor executor =  anExecutor;</span><br><span class="line">executor.execute(new RunnableTask1());</span><br><span class="line">executor.execute(new RunnableTask2());</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="Executor-的执行方案"><a href="#Executor-的执行方案" class="headerlink" title="Executor 的执行方案"></a>Executor 的执行方案</h2><p><code>Executor</code> 接口并不强制异步执行任务。一个简单的例子是，执行器可以在调用线程中立刻运行提交任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DirectExecutor implements Executor &#123;</span><br><span class="line">   public void execute(Runnable r) &#123;</span><br><span class="line">     r.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>更加典型的方案是，在其它线程而非调用者线程中执行任务。下面的 executor 为每个任务创建了一个执行线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ThreadPerTaskExecutor implements Executor &#123;</span><br><span class="line">   public void execute(Runnable r) &#123;</span><br><span class="line">     new Thread(r).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>很多 <code>Executor</code> 的实现对任务何时以何种方式执行都会添加一些限制。下面的执行器将提交的任务按顺序在另一个执行器中执行，成为一个组合执行器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class SerialExecutor implements Executor &#123;</span><br><span class="line">  final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">  final Executor executor;</span><br><span class="line">  Runnable active;</span><br><span class="line"></span><br><span class="line">  SerialExecutor(Executor executor) &#123;</span><br><span class="line">    this.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">    tasks.offer(new Runnable() &#123;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          r.run();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">  // 每个任务执行完后，执行下一个任务</span><br><span class="line">          scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// 没有任务的时候，启动此任务</span><br><span class="line">if (active == null) &#123;</span><br><span class="line">      scheduleNext();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected synchronized void scheduleNext() &#123;</span><br><span class="line">    // 当下一个任务存在时，执行任务</span><br><span class="line">    if ((active = tasks.poll()) != null) &#123;</span><br><span class="line">      executor.execute(active);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h1><h2 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h2><p><code>Executor</code> 有一个扩展接口 <code>ExecutorService</code>。<code>ExecutorService</code> 能够提供方法来管理终止，也能够创建 <code>Future</code> 来跟踪一个或多个任务的异步执行过程。该接口如下图所示：<br><img src="/images/00024/01.png" alt=""></p><h2 id="ExecutorService-关闭"><a href="#ExecutorService-关闭" class="headerlink" title="ExecutorService 关闭"></a>ExecutorService 关闭</h2><p><code>ExecutorService</code> 可以被关闭，关闭后它会拒绝新的任务。有两种关闭 <code>ExecutorService</code> 的方法：</p><ul><li><code>shutdown</code>：该方法将会保证关闭之前提交的任务会在关闭前被执行。</li><li><code>shutdownNow</code>：将会阻止任务的启动，并且尝试停止当前执行的任务。</li></ul><p>一旦 <code>ExecutorService</code> 被关闭（termination），执行器将会没有正在运行的任务、没有正在等待执行的任务、没有新的任务被提交。一个没有使用的 <code>ExecutorService</code> 应该被关闭，从而使得资源可以被回收，</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p><code>submit</code> 方法扩展于 <code>Executor</code> 中的基本方法 <code>execute(Runnable)</code>，该方法创建和返回了一个 <code>Future</code> 对象，通过这个对象可以取消任务的执行或者等待任务的结束。</p><p><code>invokeAny</code> 和 <code>invokeAll</code> 方法可以用来执行非常通用有效的批量执行。执行一批任务，等待它们中的一个或者全部执行完成。<code>ExecutorCompletionService</code> 可以用来实现这些方法的变体。</p><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>下面是一个网络服务的例子。该例子通过线程池中的线程来服务到达的请求，使用到了<code>Executors</code>中的 <code>newFixedThreadPool</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NetworkService implements Runnable &#123;</span><br><span class="line">   private final ServerSocket serverSocket;</span><br><span class="line">   private final ExecutorService pool;</span><br><span class="line"></span><br><span class="line">   public NetworkService(int port, int poolSize)</span><br><span class="line">       throws IOException &#123;</span><br><span class="line">     serverSocket = new ServerSocket(port);</span><br><span class="line">     pool = Executors.newFixedThreadPool(poolSize);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void run() &#123; // run the service</span><br><span class="line">     try &#123;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">         pool.execute(new Handler(serverSocket.accept()));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; catch (IOException ex) &#123;</span><br><span class="line">       pool.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Handler implements Runnable &#123;</span><br><span class="line">   private final Socket socket;</span><br><span class="line">   Handler(Socket socket) &#123; this.socket = socket; &#125;</span><br><span class="line">   public void run() &#123;</span><br><span class="line">     // read and service request on socket</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码展示了通过两个阶段关闭 <code>ExecutorService</code>:</p><ul><li>首先，调用 <code>shutdown</code> 来拒绝之后到达的任务。</li><li>然后，如果有必要的话，可调用 <code>shutdownNow</code> 来取消滞留的任务。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void shutdownAndAwaitTermination(ExecutorService pool) &#123;</span><br><span class="line">  pool.shutdown(); // Disable new tasks from being submitted</span><br><span class="line">  try &#123;</span><br><span class="line">    // Wait a while for existing tasks to terminate</span><br><span class="line">    if (!pool.awaitTermination(60, TimeUnit.SECONDS)) &#123;</span><br><span class="line">      pool.shutdownNow(); // Cancel currently executing tasks</span><br><span class="line">      // Wait a while for tasks to respond to being cancelled</span><br><span class="line">      if (!pool.awaitTermination(60, TimeUnit.SECONDS))</span><br><span class="line">          System.err.println(&quot;Pool did not terminate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">    // (Re-)Cancel if current thread also interrupted</span><br><span class="line">    pool.shutdownNow();</span><br><span class="line">    // Preserve interrupt status</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p><code>ThreadPoolExecutor</code> 类提供了一个可扩展的线程池实现。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>线程池用来解决两个不同方面的问题：</p><ol><li>由于减少了每个任务的调用开销，通常可以在执行大量异步任务的时候提高性能。</li><li>提供了资源控制和管理的。</li></ol><p>每个 <code>ThreadPoolExecutor</code> 具有一些基本的统计，例如：任务执行完成的数量。</p><p>为了适应广泛的应用场景，该类提高了很多可以调整的参数以及可以扩展的钩子。此外，更简单的一种方式是使用 <code>Executors</code> 中的一些工厂方法，包括：</p><ul><li><code>newCachedThreadPool</code>：没有边界，自带线程复用。</li><li><code>newFixedThreadPool</code>：固定线程池大小。 </li><li><code>newSingleThreadExecutor</code>: 单线程。</li></ul><p>这些覆盖了大部分通用的场景。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>当需要手工配置这个类或者对其参数进行调整时，就需要了解其构造函数。<code>ThreadPoolExecutor</code> 有很多构造函数，下面是最常见的形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                           int maximumPoolSize,</span><br><span class="line">                           long keepAliveTime,</span><br><span class="line">                           TimeUnit unit,</span><br><span class="line">                           BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                           ThreadFactory threadFactory,</span><br><span class="line">                           RejectedExecutionHandler handler) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h3 id="corePoolSize-and-maximumPoolSize"><a href="#corePoolSize-and-maximumPoolSize" class="headerlink" title="corePoolSize and maximumPoolSize"></a>corePoolSize and maximumPoolSize</h3><p><code>ThreadPoolExecutor</code> 将自动通过基本大小（corePoolSize）、最大大小（maximumPoolSize）来调整线程池的大小。</p><p>当有新的任务通过 <code>execute(Runnable)</code> 方法提交时：</p><ul><li>如果当前运行的线程数目小于基本大小（corePoolSize），即使有其它空闲线程，也将会创建一个新的线程来处理这个请求。</li><li>如果当前运行的线程数目大于基本大小（corePoolSize），小于最大大小（maximumPoolSize），并且缓存的队列（queue）满的时候，将会创建新的线程。</li></ul><p>设置示例：</p><ul><li>通过设置 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，你可以创建一个固定大小（fixed-size）的线程池。</li><li>通过将 <code>maximumPoolSize</code> 设置成一个很大的值，比如：<code>Integer.MAX_VALUE</code>，可以使线程池容纳任意数量的并发任务。</li></ul><p>通常，这些参数在构造函数中被设置，但是它们也可以通过这些方法动态改变：</p><ul><li><code>setCorePoolSize</code></li><li><code>setMaximumPoolSize</code></li></ul><h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>如果线程池中当前执行的线程数目大于 <code>corePoolSize</code>，那么对于多出的线程，当它们空闲的时间超过 <code>keepAliveTime</code> 时，它们将被终止。</p><p>这样的机制，使得当线程池不活跃的时候，可以减少资源的消耗。当线程池变得活跃的时候，新的线程会被创建。这个参数也通过 <code>setKeepAliveTime(long TimeUnit)</code> 方法动态改变。</p><p>通过设置这个参数为 <code>Long.MAX_VALUE</code> <code>TimeUnit.NANOSECONDS</code>，可以禁止空闲的线程被终止。</p><p>默认情况下，这个 <code>keep-alive</code> 策略只会在当前线程数目超过 <code>corePoolSize</code> 的时候才会起作用，也可以通过 <code>allowCoreThreadTimeOut(boolean)</code> 来控制，此时 <code>keepAliveTime</code> 的值不能为0. </p><h3 id="Queuing"><a href="#Queuing" class="headerlink" title="Queuing"></a>Queuing</h3><p><code>BlockingQueue</code> 可以用来转移和持有提交的任务。它的使用时和线程池的大小相关的：</p><ul><li>如果小于 <code>corePoolSize</code> 数目的线程在运行，那么 <code>Executor</code> 倾向于创建新的线程来执行任务，而不是将任务缓存到队列中。</li><li>如果大于等于 <code>corePoolSize</code> 数目的线程在运行，那么 <code>Executor</code> 倾向于将任务缓存到队列中，而不是创建新的线程。</li><li>如果请求达到限制无法被缓存到队列中，那么一个新的线程将会被创建，当创建的线程数将要超过 <code>maximumPoolSize</code> 时，新的任务将会被拒绝。</li></ul><p>以下是一些通用的队列策略：</p><ul><li>直接切换：工作队列一个好的默认选择可以是 <code>SynchronousQueue</code>，它可以将任务交给线程执行，并且不需要缓存任务。当没有线程可用的时候，尝试缓存任务到队列中将会立即失败，因此一个新的线程将会被创建。这个策略可以避免由于任务间存在内部依赖造成的死机。直接切换通常需要一个没有限制的 <code>maximumPoolSizes</code>，从而避免拒绝新的任务，但当处理不够及时，线程数目也会持续增加。</li><li>无界队列：使用无界队列（例如：<code>LinkedBlockingQueue</code> 没有预先定义队列容量），如果所有的 <code>corePoolSize</code> 线程都很忙碌，那么新的任务将会被保存在队列中进行等待。因此，线程数永远不会超过 <code>corePoolSize</code>，而 <code>maximumPoolSize</code> 的值在这里也不会起作用。这样的策略比较适合于每个任务都是独立执行的场景。例如，在 Web 页面服务中，队列可以用来平滑瞬时的访问高峰。</li><li>有界队列：一个有界限的队列（例如：<code>ArrayBlockingQueue</code>）可以防止 <code>maximumPoolSizes</code> 被设置为无限大时造成的资源耗尽。队列的大小和线程池大小可以互相调和：使用大的队列和小的线程池可以降低 CPU 使用率、操作系统资源占有、上下文切换的开销，但是会导致较低的吞吐量。如果任务经常被阻塞（I/O 受限），系统可能会调度更多的线程，超过你开始的限制。当使用小队列的时候，需要使用较大的线程池大小，这可以使得 CPU 更加忙碌，但是可能会由于频繁的上下文切换，导致吞吐量下降。</li></ul><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p><code>ThreadFactory</code> 是用来创建新的线程。下面是该接口的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @since 1.5</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> */</span><br><span class="line">public interface ThreadFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构建线程 Thread。实现中可以设置优先权、名字、守护状态、线程组等。</span><br><span class="line">     *</span><br><span class="line">     * @param r 一个可以被线程实例运行的任务</span><br><span class="line">     * @return 创建的线程或者 null (创建被拒绝)</span><br><span class="line">     */</span><br><span class="line">    Thread newThread(Runnable r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该接口一个简单的实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SimpleThreadFactory implements ThreadFactory &#123;</span><br><span class="line">  public Thread newThread(Runnable r) &#123;</span><br><span class="line">    return new Thread(r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p><p><code>Executors</code> 中的 <code>defaultThreadFactory</code> 方法提供了一个更加简单实用的实现，可以设置线程环境为已知值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br><span class="line">    private final ThreadGroup group;</span><br><span class="line">    private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br><span class="line">    private final String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != null) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = &quot;pool-&quot; +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     &quot;-thread-&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        Thread t = new Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              0);</span><br><span class="line">        if (t.isDaemon())</span><br><span class="line">            t.setDaemon(false);</span><br><span class="line">        if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Rejected-tasks"><a href="#Rejected-tasks" class="headerlink" title="Rejected tasks"></a>Rejected tasks</h3><p>在以下两种情况下，新的任务将会被拒绝：</p><ul><li><code>Executor</code> 被关闭。</li><li><code>Executor</code> 使用有界的线程池大小和工作队列容量后，达到饱和。</li></ul><p>任何一种情况下，都会调用 <code>RejectedExecutionHandler</code> 中的 <code>rejectedExecution</code> 方法。</p><p>预先定义的一些拒绝策略包括：</p><ul><li>默认是 <code>ThreadPoolExecutor.AbortPolicy</code>，它在拒绝时会抛出一个运行时异常 <code>RejectedExecutionException</code>。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code> 策略是让调用者自己来运行这个任务。这实现了一个简单的反馈控制机制，来降低新任务的提交速率。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code> 方法直接丢弃任务。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code> 如果 executor 没有被关闭，那么丢弃队列头上的任务，任务执行会再次尝试。</li></ul><h2 id="扩展例子"><a href="#扩展例子" class="headerlink" title="扩展例子"></a>扩展例子</h2><p>很多基于该类的扩展都是覆盖一个或多个受保护的函数。下面例子就展示了一个子类，该之类添加了简单的暂停和恢复特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class PausableThreadPoolExecutor extends ThreadPoolExecutor &#123;</span><br><span class="line">   private boolean isPaused;</span><br><span class="line">   private ReentrantLock pauseLock = new ReentrantLock();</span><br><span class="line">   private Condition unpaused = pauseLock.newCondition();</span><br><span class="line"></span><br><span class="line">   public PausableThreadPoolExecutor(...) &#123; super(...); &#125;</span><br><span class="line"></span><br><span class="line">   protected void beforeExecute(Thread t, Runnable r) &#123;</span><br><span class="line">     super.beforeExecute(t, r);</span><br><span class="line">     pauseLock.lock();</span><br><span class="line">     try &#123;</span><br><span class="line">       while (isPaused) unpaused.await();</span><br><span class="line">     &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">       t.interrupt();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       pauseLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void pause() &#123;</span><br><span class="line">     pauseLock.lock();</span><br><span class="line">     try &#123;</span><br><span class="line">       isPaused = true;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       pauseLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void resume() &#123;</span><br><span class="line">     pauseLock.lock();</span><br><span class="line">     try &#123;</span><br><span class="line">       isPaused = false;</span><br><span class="line">       unpaused.signalAll();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       pauseLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h1><p><code>Executors</code> 类提供了方便的工厂方法来创建这些执行器。</p><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>该方法创建的线程池可以重复使用固定数目的线程，使用无限制的队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>单线程执行，使用无限制的队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>使用无限制的线程池，空线程超过60秒被回收，线程执行采用直接交付策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>采用 <code>ScheduledThreadPoolExecutor</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><p>采用 <code>ForkJoinPool</code> , 开始于 JDK 1.8。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newWorkStealingPool(int parallelism) &#123;</span><br><span class="line">    return new ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         null, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="阿里编程规范"><a href="#阿里编程规范" class="headerlink" title="阿里编程规范"></a>阿里编程规范</h1><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>线程池不允许实用 <code>Executor</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式可以更加明确线程次的运行规则，规避资源耗尽的风险。</p><p><code>Executor</code> 各个方法的弊端说明：</p><ul><li><code>newFixedThreadPool</code> 和 <code>newSingleThreadPool</code>：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li><li><code>newCachedThreadPool</code> 和 <code>newScheduledThreadPool</code>：主要问题是线程的最大数是 <code>Integer.MAX_VALUE</code>，可能会创建非常多的线程数，甚至 OOM。</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>例子1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// org.apache.commons.lang3.concurrent.BasicThreadFactory</span><br><span class="line">ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,</span><br><span class="line">    new BasicThreadFactory.Builder().namingPattern(&quot;example-schedule-pool-%d&quot;).daemon(true).build());</span><br></pre></td></tr></table></figure></p><p>例子2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// com.google.common.util.concurrent.ThreadFactoryBuilder</span><br><span class="line">ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">    .setNameFormat(&quot;demo-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">// Common Thread Pool</span><br><span class="line">ExecutorService pool = new ThreadPoolExecutor(5,200,</span><br><span class="line">    0L,TimeUnit.MILLISECONDS,</span><br><span class="line">    new LinkedBlockingDeque&lt;Runnable&gt;(1024),namedThreadFactory,</span><br><span class="line">    new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">pool.shutdown(); // gracefully shutdown</span><br></pre></td></tr></table></figure></p><p>例子3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userThreadPool&quot;</span><br><span class="line">        class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;corePoolSize&quot; value=&quot;10&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;maxPoolSize&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;queueCapacity&quot; value=&quot;2000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;thradFactory&quot;  value= thradFactory /&gt;</span><br><span class="line">        &lt;property name=&quot;rejectedExecutionHandler&quot;&gt;</span><br><span class="line">            &lt;ref local=&quot;rejectedExecutionHandler&quot;&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对 Java 中的线程池的使用进行学习。是对以下文章的摘录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 源码&lt;/li&gt;
&lt;li&gt;阿里编程规范插件提示&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mindawei.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="线程池" scheme="http://mindawei.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的SPI机制</title>
    <link href="http://mindawei.github.io/2018/03/03/Java%E4%B8%AD%E7%9A%84SPI%E6%9C%BA%E5%88%B6/"/>
    <id>http://mindawei.github.io/2018/03/03/Java中的SPI机制/</id>
    <published>2018-03-03T08:38:16.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对 Java 中的 SPI 机制进行学习。是对以下文章的摘录：</p><ul><li><a href="http://singleant.iteye.com/blog/1497259" target="_blank" rel="noopener">《Java spi机制浅谈》</a></li><li><a href="http://blog.csdn.net/quhongwei_zhanqiu/article/details/41577159" target="_blank" rel="noopener">《Dubbo原理解析-Dubbo内核实现之SPI简单介绍》</a></li><li><a href="http://blog.csdn.net/guhong5153/article/details/61210511" target="_blank" rel="noopener">《Dubbo源码分析 —- 基于SPI的扩展实现机制》</a></li></ul><a id="more"></a><h1 id="具体约定"><a href="#具体约定" class="headerlink" title="具体约定"></a>具体约定</h1><p>当服务的提供者，提供了服务接口的一种实现之后，在 jar 包的 <code>META-INF/services/</code> 目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该 jar 包 <code>META-INF/services/</code> 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p><p>基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。JDK 提供服务实现查找的一个工具类：<code>java.util.ServiceLoader</code></p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><strong>1.common-logging</strong><br>apache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现，发现日志提供商是通过扫描 <code>META-INF/services/org.apache.commons.logging.LogFactory</code> 配置文件，通过读取该文件的内容找到日志提工商实现类。只要我们的日志实现里包含了这个文件，并在文件里制定 <code>LogFactory</code> 工厂接口的实现类即可。</p><p><strong>2.jdbc</strong><br>jdbc4.0 以前，开发人员还需要基于 <code>Class.forName(&quot;xxx&quot;)</code> 的方式来装载驱动。jdbc4 开始也基于 spi 的机制来发现驱动提供商了，可以通过 <code>META-INF/services/java.sql.Driver</code> 文件里指定实现类的方式来暴露驱动提供者。</p><p><strong>3.自己编写简单例子</strong><br>假设有一个内容搜索系统，分为展示和搜索两个模块。展示和搜索基于接口编程。搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。实例代码如下</p><p>以下代码托管在 <a href="https://github.com/mindawei/java-spi-demo" target="_blank" rel="noopener"><strong>java-spi-demo</strong></a>。</p><p><code>Search.java</code> : 搜索接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package search;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * @author &lt;url&gt;http://singleant.iteye.com/blog/1497259&lt;/url&gt;</span><br><span class="line"> */</span><br><span class="line">public interface Search &#123;</span><br><span class="line">    List&lt;Object&gt; search(String keyword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>FileSearch.java</code> : 文件系统的搜索实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package search;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * @author &lt;url&gt;http://singleant.iteye.com/blog/1497259&lt;/url&gt;</span><br><span class="line"> */</span><br><span class="line">public class FileSearch implements Search &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Object&gt; search(String keyword) &#123;</span><br><span class="line">        System.out.println(&quot;now use file system search. keyword:&quot; + keyword);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DatabaseSearch.java</code> : 数据库的搜索实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package search;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * @author &lt;url&gt;http://singleant.iteye.com/blog/1497259&lt;/url&gt;</span><br><span class="line"> */</span><br><span class="line">public class DatabaseSearch implements Search &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Object&gt; search(String keyword) &#123;</span><br><span class="line">        System.out.println(&quot;now use database search. keyword:&quot; + keyword);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SearchTest.java</code> : 测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package search;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line">/**</span><br><span class="line"> * @author &lt;url&gt;http://singleant.iteye.com/blog/1497259&lt;/url&gt;</span><br><span class="line"> */</span><br><span class="line">public class SearchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; searchIterator = s.iterator();</span><br><span class="line">        if (searchIterator.hasNext()) &#123;</span><br><span class="line">            Search curSearch = searchIterator.next();</span><br><span class="line">            curSearch.search(&quot;test&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;请检 META-INF 查文件路径是否正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 <code>META-INF/services/search.Search</code> 中是 <code>search.DatabaseSearch</code> 输出结果是：<br><code>now use database search. keyword:test</code> 。<br><img src="/images/00023/01.png" alt=""></p><p>当 <code>META-INF/services/search.Search</code> 中是 <code>search.FileSearch</code> 输出结果是：<br><code>now use file system search. keyword:test</code> 。<br><img src="/images/00023/02.png" alt=""></p><p><strong>可以看出SearchTest里没有任何和具体实现有关的代码，而是基于spi的机制去查找服务的实现</strong>。</p><p><strong>4.另一个例子</strong><br>可以查看<a href="http://blog.csdn.net/quhongwei_zhanqiu/article/details/41577159" target="_blank" rel="noopener">《Dubbo原理解析-Dubbo内核实现之SPI简单介绍》</a>。</p><h1 id="Dubbo-扩展"><a href="#Dubbo-扩展" class="headerlink" title="Dubbo 扩展"></a>Dubbo 扩展</h1><p>Dubbo 的 SPI 机制是在标准的 jdk 的 SPI 的机制上扩展加强而来的，SPI 的实现在 dubbo 中由以下几个 annotation 来实现。 </p><ol><li><code>SPI</code> 注解，，使用 SPI 注解来标识一个扩展点，该注解一般是打在接口上的，dubbo 的扩展点都是基于接口的。 </li><li><code>Adaptive</code> 注解 该注解主要作用在方法上，使用该注解可以根据方法的参数值来调用的具体的实现类的对应方法。</li><li><code>Activate</code> 注解，该注解一般作用在实现类上，使用该注解一般是对于 <code>Filter</code> 类型的类，来决定是该类是否加入到 <code>Filter</code> 的执行器责任链中。</li></ol><p><code>ExtensionLoader</code> 是 SPI 机制实现的核心类，该类提供了以下静态方法 <code>getExtensionLoader（Class type）</code>，该方法返回了加载此 <code>class</code> 的 <code>ExtensionLoader</code>， 通过该 <code>ExtensionLoader</code> 来创建对应的 type 的类的实例，该类还提供了以下方法来获取对应的加载类的实例 </p><ol><li><code>getAdaptiveExtension（String name）</code> </li><li><code>public T getExtension(String name)</code> </li></ol><p>具体可参考 <a href="http://blog.csdn.net/guhong5153/article/details/61210511" target="_blank" rel="noopener">《Dubbo源码分析 —- 基于SPI的扩展实现机制》</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对 Java 中的 SPI 机制进行学习。是对以下文章的摘录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://singleant.iteye.com/blog/1497259&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Java spi机制浅谈》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/quhongwei_zhanqiu/article/details/41577159&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Dubbo原理解析-Dubbo内核实现之SPI简单介绍》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/guhong5153/article/details/61210511&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Dubbo源码分析 —- 基于SPI的扩展实现机制》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mindawei.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="SPI" scheme="http://mindawei.github.io/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>《Java并发编程实战》笔记</title>
    <link href="http://mindawei.github.io/2018/03/02/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://mindawei.github.io/2018/03/02/《Java并发编程实战》笔记/</id>
    <published>2018-03-02T06:58:23.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>将之前《Java并发编程实战》笔记 pdf 版本转换为网页博客，方便查看和完善。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之所以在计算机中加入操作系统来实现多个程序的同时执行，主要基于以下原因：资源利用率、公平性、便利性。</p><h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>修复线程不安全的三种方式：<br>（1）不在线程之间共享该状态变量。<br>（2）将状态变量修改为不可变的变量。<br>（3）在访问转态变量时使用同步。</p><h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p><p>无状态对象一定是线程安全的。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>将“先检查后执行”以及“读取-修改-写入”等操作统称为复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。</p><p>在实际情况中，应尽可能地使用现有的线程安全对象（例如AtomicLong、AtomicReference）来管理类的状态。</p><h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。</p><p>Java的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。</p><p>由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作粒度是“线程”，而不是“调用”。</p><p>当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这个可能破坏安全性）。</p><h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><p>在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行一些意向不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p><p>当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。</p><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。</p><p>volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>volatile变量是一种比sychronized关键字更轻量级的同步机制。但不建议过度依赖volatile变量提供的可见性。</p><p>volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）。</p><p>对于服务器应用程序，无论在开发阶段还是在测试阶段，当启动JVM时一定都要指定-server命令行选项。server模式的JVM将比client模式进行更多优化，因此，在开发环境（client模式的JVM）中能正确运行的代码可能会在部署环境（server模式的JVM）中运行失败。</p><p>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。</p><h2 id="发布与溢出"><a href="#发布与溢出" class="headerlink" title="发布与溢出"></a>发布与溢出</h2><p>“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。</p><p>当某个不该发布的对象被发布时，这种情况就被称为逸出（Escape）。</p><h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><p>如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement）。</p><p>Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。</p><p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。</p><p>ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。</p><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>不可变对象（Immutable Object）一定是线程安全的。</p><p>即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。</p><p>当满足以下条件时，对象才是不可变的：<br>（1）对象创建以后其状态就不能修改。<br>（2）对象的所有域都是final类型（技术上不一定都要final,如String）。<br>（3）对象是正确创建的（在对象创建期间，this引用没有溢出）。</p><p>在Java内存中，final域还有着特殊的语义。Final可以确保初始化过程的安全性。</p><h2 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h2><p>要正确的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式发布：<br>（1）在静态初始化函数中初始化一个对象引用。<br>（2）将对象的引用保存到volatile类型的域或者AtomicReferance对象中。<br>（3）将对象的引用保存到某个正确构造对象的final类型中。<br>（4）将对象的引用保存到一个由锁保护的域中。</p><p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。</p><p>在并发程序中使用和共享对象时，可以使用的一些实用的策略，包括：<br>（1）线程封闭。<br>（2）只读共享。<br>（3）线程安全共享（在对象内部实现同步，外部可以安全访问）。<br>（4）保护对象（通过特定的锁来访问）。</p><h1 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h1><h2 id="设计线程安全的类"><a href="#设计线程安全的类" class="headerlink" title="设计线程安全的类"></a>设计线程安全的类</h2><p>包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在单个原子操作中进行读取或更新。</p><h2 id="实例封闭"><a href="#实例封闭" class="headerlink" title="实例封闭"></a>实例封闭</h2><p>一些基本的容器并非线程安全的，例如ArrayList和HashMap，但类库提供了包装器工厂方法（例如Collections.synchronizedList及其类似方法），使得这些线程安全的类在多线程环境中安全地使用。</p><p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析线程安全性时就无须检查整个程序。</p><h2 id="线程安全性的委托"><a href="#线程安全性的委托" class="headerlink" title="线程安全性的委托"></a>线程安全性的委托</h2><p>略</p><h2 id="在现有的线程安全类中添加功能"><a href="#在现有的线程安全类中添加功能" class="headerlink" title="在现有的线程安全类中添加功能"></a>在现有的线程安全类中添加功能</h2><p>重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。</p><p>客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的合在一起，这会破坏封装性。</p><p>当为现有的类添加一个原子操作时，有一种更好的方式：组合（Composition）。</p><h2 id="将同步策略文档化"><a href="#将同步策略文档化" class="headerlink" title="将同步策略文档化"></a>将同步策略文档化</h2><p>在维护线程安全的时，文档是最强大的（同时也是最未被重发利用的）工具之一。</p><p>在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。</p><h1 id="基础构件模块"><a href="#基础构件模块" class="headerlink" title="基础构件模块"></a>基础构件模块</h1><h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>如果不想在迭代期间对容器加锁，那么一种替代方法就是“克隆”容器，并在副本上进行迭代。</p><p>容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。所有这些间接地迭代操作都可能抛出ConcurrentModificationException。</p><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</p><p>虽然可以用List来模拟Queue的行为，但还需要一个Queue的类，因为它能去掉List的随机访问需求，从而实现了更高效的并发。</p><p>ConcurrentHashMap使用了一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁（Lock Striping）。</p><p>ConcurrentHashMap中，由于size返回的结果在计算时已经过期了吗，所以size返回的值可能是一个近似值而不是精确值。</p><p>“写入时复制（Copy-On-Write）”容器的线程安全性在于，只要正确地发布一个事实不可变对象，那么在访问该对象时就不再需要进一步的同步。<br>仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。这个准则很适合事件通知系统（注册监听器）。</p><h2 id="阻塞队列和生产者-消费者模式"><a href="#阻塞队列和生产者-消费者模式" class="headerlink" title="阻塞队列和生产者 - 消费者模式"></a>阻塞队列和生产者 - 消费者模式</h2><p>阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。无界队列永远都不会充满，所以无界队列的put方法也永远不会阻塞。</p><p>在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</p><p>应该尽早地通过阻塞队列在设计中构建资源管理机制——这件事情做得越早，就越容易。</p><p>BlockingQueue的多种实现：<br>（1）LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列。<br>（2）PriorityBlockingQueue是一种按优先级排序的队列。<br>（3）SynchronousQueue维护一组线程，可以直接交付工作。</p><p>双端队列适用于工作密取（Work Stealing）模式。</p><h2 id="阻塞方法与中断方法"><a href="#阻塞方法与中断方法" class="headerlink" title="阻塞方法与中断方法"></a>阻塞方法与中断方法</h2><p>线程可能会阻塞或暂停执行，原因有多种：<br>（1）等待I/O操作结束；<br>（2）等待获得一个锁；<br>（3）等待重Thread.sleep方法中醒来；<br>（4）等待另一个线程的计算结果。</p><h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁可以确保某些活动直到其他活动都完成后才继续执行。</p><p>CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。</p><p>FutureTask也可以用做闭锁。（FutureTask实现了Future语义，表示一种抽象的可生成结果的计算）。</p><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p><p>栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件的发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。</p><p>CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。</p><p>Exchanger是一种两方（Two-Party）栅栏，各方在栅栏位置上交换数据。</p><h2 id="构建高效且可伸缩的结果缓存"><a href="#构建高效且可伸缩的结果缓存" class="headerlink" title="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存</h2><p>略</p><p>第一部分小结<br>（1）可变状态时至关重要的（It’s the mutable state,stupid）。<br>（2）尽量将域声明为final类型，除非需要它们是可变的。<br>（3）不可变对象一定是线程安全的。<br>（4）封装有助于管理复杂性。<br>（5）用来保护每个可变变量。<br>（6）当保护同一个不变性条件中的所有变量时，要使用同一个锁。<br>（7）在执行复合操作期间，要持有锁。<br>（8）如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出问题。<br>（9）不要故作聪明地推断出不需要使用同步的地方。<br>（10）在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全的。<br>（11）将通办不成策略文档化。</p><h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将之前《Java并发编程实战》笔记 pdf 版本转换为网页博客，方便查看和完善。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://mindawei.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="并发" scheme="http://mindawei.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记</title>
    <link href="http://mindawei.github.io/2018/03/02/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://mindawei.github.io/2018/03/02/《深入理解Java虚拟机》笔记/</id>
    <published>2018-03-02T06:09:04.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>将之前《深入理解Java虚拟机》笔记 pdf 版本转换为网页博客，方便查看和完善。</p><a id="more"></a><h1 id="走近Java"><a href="#走近Java" class="headerlink" title="走近Java"></a>走近Java</h1><h2 id="JDK与JRE"><a href="#JDK与JRE" class="headerlink" title="JDK与JRE"></a>JDK与JRE</h2><p>把Java程序设计语言、Java虚拟机、Java API类库称为JDK（Java Development Kit）, JDK是用于支持Java程序开发的最小环境。</p><p>把Java API类库中的Java SE API子集和Java虚拟机称为JRE（Java Runtime Environment）,JRE是支持Java程序运行的标准环境。</p><p><img src="/images/00022/01.png" alt=""></p><p>图片来自 <a href="http://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/</a></p><h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><p>Sun JDK 和 OpenJDK 中所带的虚拟机是 HotSpot VM。<br>可以参考的文档：<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/</a></p><h2 id="Java技术展望"><a href="#Java技术展望" class="headerlink" title="Java技术展望"></a>Java技术展望</h2><p>模块化（提到OSGI）、混合语言、多核并行（希望利用GPU、APU等）。</p><h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 虚拟机内存自动管理利弊：</p><ul><li>优点：不需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。</li><li>缺点：出现内存泄漏和溢出问题时，如果不了解虚拟机怎样使用内存，排查会比较艰难。</li></ul><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/images/00022/02.png" alt=""></p><p><img src="/images/00022/03.png" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）可以看成当前线程所执行的字节码的行号指示器。各个线程的程序计数器是相互独立的互不影响。</p><p>如果执行的是Java方法，计数器记录字节码指令地址；如果执行的是Native方法，计数器值为空（Undefined）。</p><p>程序计数器区域虚拟机规范中是唯一一个没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈（Java Virtual Machine Stacks）是线程私有的，描述的是Java方法执行的内存模型：每个方法在执行同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（大部分虚拟都可以）并且扩展时无法申请到足够内存，就会抛出OutOfMemoryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆（Java Heap）是被所有线程共享的一块内存区域，也是供所有类实例和数组对象分配内存的区域。</p><p>Java堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。Java堆所使用的内存不需要保证是连续的。</p><p>如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个OutOfMemoryError异常。</p><p>Java 控制堆和非堆参数例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M</span><br><span class="line">-vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了</span><br><span class="line">-Xms128m JVM初始分配的堆内存</span><br><span class="line">-Xmx512m JVM最大允许分配的堆内存，按需分配</span><br><span class="line">-XX:PermSize=64M JVM初始分配的非堆内存</span><br><span class="line">-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配</span><br></pre></td></tr></table></figure></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。方法区别名叫做Non-Heap（非堆）。</p><p>在HotSpot虚拟机上，很多人把方法区成为“永久代”（Permanent Generation）是因为HotSpot把GC分代收集扩展至方法区，用永久代实现方法区。这样做的好处是节省工作量，坏处是受到-XX:MaxPermSize的限制，更容易遇到内存溢出问题。</p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>Java虚拟机实现可能会使用到传统的栈（通常称之为“C Stacks”）来支持native方法（指使用Java以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（Native Method Stack）。当Java虚拟机使用其他语言（例如C语言）来实现指令集解释器时，也会使用到本地方法栈。</p><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常。</p><p>如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。</p><p>该书提到直接内存（Direct Memory）,JDK1.4中加入的NIO（New Input/Output）引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数直接分配堆外内存，然后通过Java堆中DirectByteBuffer对象作为这块内存的引用进行操作。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到一条new指令时：</p><ol><li>检查这个指令的参数是否能在常量池中定位到一个类符号的引用。</li><li>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有必须先执行相应的类加载过程。</li><li>虚拟机为新生对象分配内存。分配算法取决于垃圾收集器是否带有压缩整理功能。如果带有压缩整理功能（如Serial、ParNew等），Java堆规整，采用“指针碰撞”（Bump the Pointer）,否则（如 CMS）Java堆不规整,采用“空闲链表”Free List。</li><li>将分配到的内存空间都初始化为零值（不包括对象头）。</li><li>对对象头进行必要的设置（那个类的实例、如何找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等）。</li><li>调用对象的<init>方法。</init></li></ol><p><img src="/images/00022/04.png" alt=""></p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头：存储对象自身的运行时数据：Mark Word（在32bit和64bit虚拟机上长度分别为32bit和64bit），包含如下信息：</p><ol><li>对象HashCode</li><li>对象GC分代年龄</li><li>锁状态标志（轻量级锁、重量级锁）</li><li>线程持有的锁（轻量级锁、重量级锁）</li><li>偏向锁相关：偏向锁、自旋锁、轻量级锁以及其他的一些锁优化策略是JDK1.加入的，这些优化使得Synchronized的性能与ReentrantLock的性能持平，在Synchronized可以满足要求的情况下，优先使用Synchronized，除非是使用一些ReentrantLock独有的功能，例如指定时间等待等。</li><li>类型指针：对象指向类元数据的指针（32bit–&gt;32bit，64bit–&gt;64bit(未开启压缩指针)，32bit(开启压缩指针)）。JVM通过这个指针来确定这个对象是哪个类的实例（根据对象确定其Class的指针）<br>实例数据：对象真正存储的有效信息。<br>对齐填充：HotSpot VM要求对象的大小必须是8的整数倍，若不是，需要补位对齐。</li></ol><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>对象的访问方式有使用句柄和直接指针两种。</p><p>如果使用句柄访问的话，那么Java堆中将会划分出一块区域作为句柄池，reference中存的就是句柄地址。句柄中包含了实例数据和类型数据各自的地址。</p><p>如果使用直接指针访问的的话，reference中存的直接就是对象地址，对象中放置类型数据的相关信息。<br><img src="/images/00022/05.png" alt=""></p><p>使用句柄的好处：对象被移动时只需改变句柄中地址，reference本身不需要改变。使用直接指针访问的好处：速度更快，节省了一次指针定位的时间开销。<br><img src="/images/00022/06.png" alt=""></p><h2 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h2><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（简称OOM）异常的可能。</p><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>产生例子：不断创建对象，并保证GC Roots到对象之间有可达路径。</p><p>解决思路：利用工具对Dump出来的堆转储快照进行分析，重点确认内存中的对象是否必要，也就是要分清是出现内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。如果是内存泄漏，就使用工具查看泄漏对象到GC Roots的引用链，确定泄漏代码位置；如果是内存溢出则检查虚拟机的堆参数（-Xmx与-Xms)。</p><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，栈容量只由-Xss参数设定，虽然-Xoss（设置本地方法栈大小）参数存在，但实际上是无效的。</p><p>实验结果表明：单个线程下，无论由于栈帧太大还是虚拟机容量太小，当内存无法分配时候，虚拟机抛出的都是StackOverflowError异常。</p><p>当持续创建线程时，会产生OOM异常。因为线程栈空间 ≈ 总内存（操作系统内存）-Xmx（最大堆容量）-MaxPermSize（最大方法区容量），所以可以通过减少“内存”（Xmx、MaxPermSize）来解决多线程创建造成的OOM异常。  </p><h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>JDK1.7之后String.intern()方法不再复制实例到到永久代中，只是在常量池中记录首次出现的实例引用。所以通过String.intern()持续创建不会造成常量池OOM。</p><p>方法区用于存放Class的相关信息，如类名、访问修饰符、字段描述、方法描述等。基本思路是运行时产生大量的类去填满方法区，直到溢出。</p><p>可能出现溢出的场景：Spring、Hibernate使用CGLib对类进行增强、大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGI的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）等。</p><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</p><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>GC关注三件事：哪些内存需要回收？什么时候回收？如何回收？</p><p>了解GC和内存分配的意义：当需要排查内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些“自动化”的技术实施必要的监控和调节。</p><p>“内存分配和回收”中讨论的内存指的是“Java堆和方法区”，因为程序计数器、Java虚拟机栈、本地方法栈这三个区域的内存分配和回收具备确定性。</p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（Reference Counting）：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象不可能再被使用。</p><ul><li>优点：实现简单，判断效率也很高。</li><li>缺点：很难解决对象之间相互循环引用的问题。<br><img src="/images/00022/07.png" alt=""></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析（Reachability Analysis）:通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain）,从GC Roots到某个对象不可达时，则这个对象是不可用的。<br><img src="/images/00022/08.png" alt=""></p><p>在Java语言中可以作为GC Roots的对象包括以下几种：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ol><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>希望能描述这样一类对象：当内存空间还足够的时候，则能保留在内存之中；如果内存空间在进行GC后还是很紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的场景。</p><p>JDK1.2之后，Java对引用的概念进行了扩充。</p><table><thead><tr><th>引用类型</th><th>实现</th><th>存在时间</th></tr></thead><tbody><tr><td>强引用</td><td>Object obj = new Object()</td><td>只要引用还存在就存在</td></tr><tr><td>软引用</td><td>SoftReferencev</td><td>直到将要发生OOM时</td></tr><tr><td>弱引用</td><td>WeakReference</td><td>下一次GC之前</td></tr><tr><td>虚引用</td><td>PhantomReference</td><td>对对象毫无影响，只是为了在对象回收时受到一个通知</td></tr></tbody></table><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>要宣告一个对象的死亡，至少要经历两次标记过程。</p><ul><li>第一次标记：如果从GC Roots不可达，则进行第一次标记并进行筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()或者已经被调用过，则没有必要再执行该方法。</li><li>第二次标记：需要执行finalize()方法的对象会被放入F-Queue中，但是不承诺会全部执行.在执行finalize()中，可以通过重新与引用链上的任何对象建立关系，从而逃脱“死亡”。稍后，GC会对F-Queue中的对象进行第二次小规模标记。</li></ul><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区（或者Hotspot虚拟机中的永久代）主要回收两个部分的内容：废弃常量和无用的类。Java虚拟机规范说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低。</p><p>在大量使用反射、动态代理、GCLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>介绍几种垃圾收集算法。</p><table><thead><tr><th>算法名称</th><th>算法过程</th><th>算法说明</th></tr></thead><tbody><tr><td>标记-清除（Mark-Sweep）</td><td>分为“标记”和“清除”两阶段：<br>1. 标记出需要回收的的对象。<br>2. 在标记完成后统一回收。<br></td><td>效率问题：标记和清除两个过程效率都不高。<br>空间问题：标记清除后会产生大量不连续的内存碎片。</td></tr><tr><td>复制（Copying）</td><td>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。</td><td>将内存缩小为原来的一般，代价太高。</td></tr><tr><td>标记-整理(Mark-Compact)</td><td>1. 标记出需要回收的的对象。<br>2. 在标记完成后将存活的对象都向一端移动，然后直接清理掉边界以外的内存。</td><td>由于年老代中对象存活率较高，所以在年老代中采用这种算法。</td></tr><tr><td>分代收集 (Generational Collection)</td><td>把Java堆分为新生代和老年代。新生代使用“复制”算法，年老代使用“标记-清理”或者“标记-整理”算法。</td><td></td></tr></tbody></table><p>现代商业虚拟机采用复制算法来回收新生代。将内存划分为一块较大的Eden空间和两块较小的Survivor空间。当回收时，将Eden和Survivor中存活的对象一次地复制到另一块Survivor上，最后清理掉Eden和刚才用过的Survivor空间。<br>HotSpot中Eden和Survivor的比例是8:1。当Survivor空间不够用时需要依赖其他内存（这里指年老代）进行分配担保（Handle Promotion），直接进入年老代。<br><img src="/images/00022/09.png" alt=""></p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>为了确保准确性，GC进行时需要停顿所有Java执行线程（Sun 将这件事情称为 “Stop The World”）。</p><p>虚拟机有办法得知哪些地方存着对象引用，在HotSpot的实现中，使用的是一组称为OopMap的数据结构。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）,即程序执行时只有在到达安全点时才能暂停，进行GC。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域（Safe Region）可以看做是被扩展了的Safepoint。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>From: <a href="http://blog.csdn.net/chjttony/article/details/7883748" target="_blank" rel="noopener">http://blog.csdn.net/chjttony/article/details/7883748</a></p><p><img src="/images/00022/10.png" alt=""></p><p>图中如果两个垃圾收集器直接有连线，则表明这两个垃圾收集器可以搭配使用。</p><h3 id="Serial垃圾收集器"><a href="#Serial垃圾收集器" class="headerlink" title="Serial垃圾收集器"></a>Serial垃圾收集器</h3><p>Serial是一个单线程的收集器，它不仅仅只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p><p>Serial垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。</p><h3 id="ParNew垃圾收集器"><a href="#ParNew垃圾收集器" class="headerlink" title="ParNew垃圾收集器"></a>ParNew垃圾收集器</h3><p>ParNew垃圾收集器其实是Serial收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p><p>ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge是吞吐量优先的垃圾收集器，它还提供一个参数：-XX:+UseAdaptiveSizePolicy，这是个开关参数，打开之后就不需要手动指定新生代大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRation)、新生代晋升年老代对象年龄(-XX:PretenureSizeThreshold)等细节参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以达到最大吞吐量，这种方式称为GC自适应调节策略，自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。</p><p>在Server模式下，主要有两个用途：</p><ol><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。</li><li>作为年老代中使用CMS收集器的后备垃圾收集方案。</li></ol><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。</p><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。</p><p>最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验，CMS收集器是Sun HotSpot虚拟机中第一款真正意义上并发垃圾收集器，它第一次实现了让垃圾收集线程和用户线程同时工作。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收集器两个最突出的改进是：</p><ol><li>基于标记-整理算法，不产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ol><p>G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。</p><p>区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p>触发JVM进行Full GC的情况及应对策略：<br><a href="http://blog.csdn.net/chenleixing/article/details/46706039" target="_blank" rel="noopener">http://blog.csdn.net/chenleixing/article/details/46706039</a></p><h3 id="大对象直接进入年老代"><a href="#大对象直接进入年老代" class="headerlink" title="大对象直接进入年老代"></a>大对象直接进入年老代</h3><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。注意：这个参数只对Serial和ParNew两款收集器有效，Parallel Scavenge 收集器不认识这个参数。 </p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>略</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>略</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>略</p><h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>研究数据包括：运行日志、异常堆栈、GC日志、线程快照（threaddump / javacore文件）、堆转储快照（heapdump / hprof文件）等。</p><h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><p>JDK中的工具大多是jdk/lib/tools.jar类库的一层薄包装而已。借助tools.jar我们可以直接在应用程序中实现功能强大的监控分析功能，但tools.jar不是Java标准的API，如果引入这个类库，程序就只能运行与Sun Hotspot上面。</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps    JVM</td><td>Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程。</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据。</td></tr><tr><td>jinfo</td><td>Configuration Info for Java，显示虚拟机配置信息。</td></tr><tr><td>jmap</td><td>Memory Map for Java，生成虚拟机的内存转储快照（heapdump 文件）。</td></tr><tr><td>jhat</td><td>JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果。</td></tr><tr><td>jstack</td><td>Stack Trace for Java，显示虚拟机的线程快照。</td></tr></tbody></table><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h3 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h3><p>JConsole可以检测到对应线程的死锁。</p><h3 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h3><p>除了JConsole中的一些基本功能外，VisualVM还可以下载插件、生成和浏览堆转储快照、分析程序性能、BTrace动态日志跟踪。</p><h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>略</p><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>字节码（ByteCode）是构成平台无关性的基石。此外，虚拟机的另一种中立特性——语言无关性正越来越被开发者所重视。整个Class文件本质上就是一张表。</p><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的生命周期如下图所示。<br><img src="/images/00022/11.png" alt=""></p><p>虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然要在此之前开始）：<br>1）使用new实例化对象、读取一个类的静态字段（被final修饰、已在编译期把结果放入常量次的静态字段除外）、调用一个类的静态方法的时候。<br>2）反射调用的时候。<br>3）初始化类点的时候，父类未初始化的要初始化。<br>4）虚拟机启动时要初始化主类。<br>5）使用JDK1.7的动态语言支持时。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下3件事情：<br>1）通过一个类的全称限定名来获取定义此类的二进制字节流。<br>2）将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。<br>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证大致会完成下面4个阶段的检验动作：<br>1）文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br>2）元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。<br>3）字节码的验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<br>4）符号引用校验：发生在将符号引用转换为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。注意：这里是类变量（static修饰的变量），而且初始值“通畅情况下”（非final）是0值，因为复制代码还没有编译。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池内的符号引用替换为直接引用的过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。<br><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（<code>static{}</code> 块）中的语句合并产生的。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>加载器在类层次划分、OSGi、热部署、代码加密等领域大放异彩。</p><p>下图展示的类加载器之间的这种层次关系，称为双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器（一般是组合而不是继承关系）。<br><img src="/images/00022/12.png" alt=""></p><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时逼哪一期产生本地代码执行）两种选择。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p><img src="/images/00022/13.png" alt=""><br>略</p><h1 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h1><p>略</p><h1 id="早期（编译期）优化"><a href="#早期（编译期）优化" class="headerlink" title="早期（编译期）优化"></a>早期（编译期）优化</h1><p>略</p><h1 id="晚期（运行期）优化"><a href="#晚期（运行期）优化" class="headerlink" title="晚期（运行期）优化"></a>晚期（运行期）优化</h1><p>略</p><h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><p>略</p><h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将之前《深入理解Java虚拟机》笔记 pdf 版本转换为网页博客，方便查看和完善。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://mindawei.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
      <category term="Java虚拟机" scheme="http://mindawei.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>《Netty-in-Action》笔记目录</title>
    <link href="http://mindawei.github.io/2018/03/01/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/"/>
    <id>http://mindawei.github.io/2018/03/01/《Netty-in-Action》笔记目录/</id>
    <published>2018-03-01T12:51:30.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>对之前摘录的一个目录。</p><a id="more"></a><h1 id="01-Netty-—-异步和事件驱动"><a href="#01-Netty-—-异步和事件驱动" class="headerlink" title="01 Netty — 异步和事件驱动"></a><a href="https://mindawei.github.io/2018/02/08/01%20Netty%20%E2%80%94%20%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/">01 Netty — 异步和事件驱动</a></h1><ul><li>Java 中的网络使用</li><li>介绍 Netty</li><li>Netty 的核心组件</li></ul><h1 id="02-你的第一个Netty应用"><a href="#02-你的第一个Netty应用" class="headerlink" title="02 你的第一个Netty应用"></a><a href="https://mindawei.github.io/2018/02/09/02%20%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AANetty%E5%BA%94%E7%94%A8/">02 你的第一个Netty应用</a></h1><ul><li>建立开发环境</li><li>写一个回写应用的服务器和客户端</li><li>构建和测试程序</li></ul><h1 id="03-Netty的组件和设计"><a href="#03-Netty的组件和设计" class="headerlink" title="03 Netty的组件和设计"></a><a href="https://mindawei.github.io/2018/02/10/03%20Netty%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/">03 Netty的组件和设计</a></h1><ul><li>Netty 技术和架构方面的介绍</li><li><code>Channel</code>、<code>EventLoop</code> 和 <code>ChannelFuture</code></li><li><code>ChannelHandler</code> 和 <code>ChannelPipeline</code></li><li>启动（ Bootstrapping）</li></ul><h1 id="04-传输"><a href="#04-传输" class="headerlink" title="04 传输"></a><a href="https://mindawei.github.io/2018/02/11/04%20%E4%BC%A0%E8%BE%93/">04 传输</a></h1><ul><li>OIO：阻塞传输</li><li>NIO：异步传输</li><li>本地传输：和 JVM 异步交互</li><li>测试你的 <code>ChannelHandler</code></li></ul><h1 id="05-ByteBuf"><a href="#05-ByteBuf" class="headerlink" title="05 ByteBuf"></a><a href="https://mindawei.github.io/2018/02/12/05%20ByteBuf/">05 ByteBuf</a></h1><ul><li><code>ByteBuf</code>：Netty 的数据容器</li><li>API 细节</li><li>用例</li><li>内存分配</li></ul><h1 id="06-ChannelHandler-and-ChannelPipeline"><a href="#06-ChannelHandler-and-ChannelPipeline" class="headerlink" title="06 ChannelHandler and ChannelPipeline"></a><a href="https://mindawei.github.io/2018/02/14/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/">06 ChannelHandler and ChannelPipeline</a></h1><p>This chapter covers</p><ul><li>The <code>ChannelHandler</code> and <code>ChannelPipeline</code> APIs</li><li>Detecting resource leaks</li><li>Exception handling</li></ul><h1 id="07-EventLoop-and-threading-model"><a href="#07-EventLoop-and-threading-model" class="headerlink" title="07 EventLoop and threading model"></a><a href="https://mindawei.github.io/2018/02/16/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/">07 EventLoop and threading model</a></h1><p>This chapter covers</p><ul><li>Threading model overview</li><li>Event loop concept and implementation</li><li>Task scheduling</li><li>Implementation details</li></ul><h1 id="08-Bootstrapping"><a href="#08-Bootstrapping" class="headerlink" title="08 Bootstrapping"></a><a href="https://mindawei.github.io/2018/02/17/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89/">08 Bootstrapping</a></h1><p>This chapter covers</p><ul><li>Bootstrapping clients and servers</li><li>Bootstrapping clients from within a <code>Channel</code></li><li>Adding <code>ChannelHandlers</code></li><li>Using <code>ChannelOptions</code> and attributes</li></ul><h1 id="09-Unit-testing"><a href="#09-Unit-testing" class="headerlink" title="09 Unit testing"></a><a href="https://mindawei.github.io/2018/02/18/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89/">09 Unit testing</a></h1><p>This chapter covers</p><ul><li>Unit testing</li><li>Overview of <code>EmbeddedChannel</code></li><li>Testing <code>ChannelHandlers</code> with <code>EmbeddedChannel</code></li></ul><h1 id="10-The-codec-framework"><a href="#10-The-codec-framework" class="headerlink" title="10 The codec framework"></a><a href="https://mindawei.github.io/2018/02/18/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89/">10 The codec framework</a></h1><p>This chapter covers</p><ul><li>An overview of decoders, encoders and codecs</li><li>Netty’s codec classes</li></ul><h1 id="11-Provided-ChannelHandlers-and-codecs"><a href="#11-Provided-ChannelHandlers-and-codecs" class="headerlink" title="11 Provided ChannelHandlers and codecs"></a><a href="https://mindawei.github.io/2018/02/19/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89/">11 Provided ChannelHandlers and codecs</a></h1><p>This chapter covers</p><ul><li>Securing Netty applications with SSL/TLS</li><li>Building Netty HTTP/HTTPS applications</li><li>Handling idle connections and timeouts</li><li>Decoding delimited and length-based protocols</li><li>Writing big data</li></ul><h1 id="12-WebSocket"><a href="#12-WebSocket" class="headerlink" title="12 WebSocket"></a><a href="https://mindawei.github.io/2018/02/22/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89/">12 WebSocket</a></h1><p>This chapter covers</p><ul><li>The concept of a real-time web</li><li>The WebSocket protocol</li><li>Building a WebSocket-based chat room server with Netty</li></ul><h1 id="13-Broadcasting-events-with-UDP"><a href="#13-Broadcasting-events-with-UDP" class="headerlink" title="13 Broadcasting events with UDP"></a><a href="https://mindawei.github.io/2018/02/22/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89/">13 Broadcasting events with UDP</a></h1><p>This chapter covers</p><ul><li>An overview of UDP</li><li>A sample broadcasting application</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对之前摘录的一个目录。&lt;/p&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://mindawei.github.io/categories/Netty/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty" scheme="http://mindawei.github.io/tags/Netty/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Netty-in-Action》笔记（13）</title>
    <link href="http://mindawei.github.io/2018/02/22/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89/"/>
    <id>http://mindawei.github.io/2018/02/22/《Netty-in-Action》笔记（13）/</id>
    <published>2018-02-22T08:00:48.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Broadcasting-events-with-UDP"><a href="#Broadcasting-events-with-UDP" class="headerlink" title="Broadcasting events with UDP"></a>Broadcasting events with UDP</h1><p>This chapter covers</p><ul><li>An overview of UDP</li><li>A sample broadcasting application</li></ul><a id="more"></a><h2 id="UDP-basics"><a href="#UDP-basics" class="headerlink" title="UDP basics"></a>UDP basics</h2><p>UDP is much faster than TCP: all overhead of handshaking and message management has been eliminated. Clearly, UDP is a good fit for applications that can handle or tolerate lost messages, unlike those that handle financial transactions</p><h2 id="UDP-broadcast"><a href="#UDP-broadcast" class="headerlink" title="UDP broadcast"></a>UDP broadcast</h2><p>All of our examples so far have utilized a transmission mode called <em>unicast</em>, defined as the sending of messages to a single network destination identified by a unique address.</p><p>UDP provides additional transmission modes for sending a message to multiple recipients:</p><ul><li><em>Multicast</em> — Transmission to a defined group of hosts</li><li><em>Broadcast</em> — Transmission to all of the hosts on a network (or a subnet)</li></ul><h2 id="The-UDP-sample-application"><a href="#The-UDP-sample-application" class="headerlink" title="The UDP sample application"></a>The UDP sample application</h2><blockquote><p><strong>PUBLISH/SUBSCRIBE</strong><br>Applications like syslog are typically classified as publish/subscribe: a producer or service publishes the events, and multiple clients subscribe to receive them.</p></blockquote><p>Figure 13.1 presents a high-level view of the overall system, which consists of a broadcaster and one or more event monitors.<br><img src="/images/00021/01.png" alt="Figure 13.1 Broadcast  system overview" title="Figure 13.1 Broadcast  system overview"> </p><h2 id="The-message-POJO-LogEvent"><a href="#The-message-POJO-LogEvent" class="headerlink" title="The message POJO: LogEvent"></a>The message POJO: LogEvent</h2><p>Listing 13.1 shows the details of this the POJO <code>LogEvent</code>.<br><img src="/images/00021/02.png" alt=""> </p><h2 id="Writing-the-broadcaster"><a href="#Writing-the-broadcaster" class="headerlink" title="Writing the broadcaster"></a>Writing the broadcaster</h2><p>The primary ones we’ll be using are the message containers and Channel types listed in the following table.<br><img src="/images/00021/03.png" alt=""> </p><p>Figure 13.2 shows the broadcasting of three log entries, each one via a dedicated <code>DatagramPacket</code>.<br><img src="/images/00021/04.png" alt="Figure 13.2 Log entries sent via DatagramPackets" title="Figure 13.2 Log entries sent via DatagramPackets"> </p><p>Figure 13.3 represents a high-level view of the <code>ChannelPipeline</code> of the <code>LogEventBroadcaster</code>, showing how <code>LogEvents</code> flow through it.<br><img src="/images/00021/05.png" alt=""> </p><p>The next listing shows our customized version of <code>MessageToMessageEncoder</code>, which performs the conversion just described.<br><img src="/images/00021/06.png" alt=""> </p><p><em>netcat</em> is perfect for basic testing of this application; it just listens on a specified port and prints all data received to standard output. Set it to listen for UDP data on port 9999 as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l -u 9999</span><br></pre></td></tr></table></figure></p><h2 id="Writing-the-monitor"><a href="#Writing-the-monitor" class="headerlink" title="Writing the monitor"></a>Writing the monitor</h2><p>This program will </p><ol><li>Receive UDP <code>DatagramPackets</code> broadcast by the <code>LogEventBroadcaster</code></li><li>Decode them to <code>LogEvent</code> messages</li><li>Write the <code>LogEvent</code> messages to <code>System.out</code></li></ol><p>Figure 13.4 depicts the <code>ChannelPipeline</code> of the <code>LogEventMonitor</code> and shows how <code>LogEvents</code> will flow through it.<br><img src="/images/00021/07.png" alt="Figure 13.4 LogEventMonitor" title="Figure 13.4 LogEventMonitor"></p><p>The following listing shows <code>LogEventDecoder</code>.<br><img src="/images/00021/08.png" alt=""> </p><p>The following listing shows <code>LogEventHandler</code>.<br><img src="/images/00021/09.png" alt=""> </p><p>The following listing shows <code>LogEventMonitor</code>.<br><img src="/images/00021/10.png" alt=""> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Broadcasting-events-with-UDP&quot;&gt;&lt;a href=&quot;#Broadcasting-events-with-UDP&quot; class=&quot;headerlink&quot; title=&quot;Broadcasting events with UDP&quot;&gt;&lt;/a&gt;Broadcasting events with UDP&lt;/h1&gt;&lt;p&gt;This chapter covers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An overview of UDP&lt;/li&gt;
&lt;li&gt;A sample broadcasting application&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://mindawei.github.io/categories/Netty/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty" scheme="http://mindawei.github.io/tags/Netty/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Netty-in-Action》笔记（12）</title>
    <link href="http://mindawei.github.io/2018/02/22/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89/"/>
    <id>http://mindawei.github.io/2018/02/22/《Netty-in-Action》笔记（12）/</id>
    <published>2018-02-22T03:14:49.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>This chapter covers</p><ul><li>The concept of a real-time web</li><li>The WebSocket protocol</li><li>Building a WebSocket-based chat room server with Netty</li></ul><a id="more"></a><p>So for now we’ll accept the following non-authoritative description from Wikipedia as adequate: </p><blockquote><p>The <em>real-time</em> web is a network web using technologies and practices that enable users to receive information as soon as it is published by its authors, rather than requiring that they or their software check a source periodically for updates. </p></blockquote><h2 id="Introducing-WebSocket"><a href="#Introducing-WebSocket" class="headerlink" title="Introducing WebSocket"></a>Introducing WebSocket</h2><p>The WebSocket protocol was designed from the ground up to provide a practical solution to the problem of bidirectional data transmission on the web, allowing client and server to transmit messages at any time and, consequently, requiring them to handle message receipt asynchronously. </p><h2 id="Our-example-WebSocket-application"><a href="#Our-example-WebSocket-application" class="headerlink" title="Our example WebSocket application"></a>Our example WebSocket application</h2><p>Figure 12.1 illustrates the application logic:<br>1 A client sends a message.<br>2 The message is broadcast to all other connected clients.<br><img src="/images/00020/01.png" alt="Figure 12.1 WebSocket application logic" title="Figure 12.1 WebSocket application logic"> </p><h2 id="Adding-WebSocket-support"><a href="#Adding-WebSocket-support" class="headerlink" title="Adding WebSocket support"></a>Adding WebSocket support</h2><p>A mechanism known as the <em>upgrade handshake</em> is used to switch from standard HTTP or HTTPS protocol to WebSocket.</p><p>Figure 12.2 illustrates the server logic, which, as always in Netty, will be implemented by a set of <code>ChannelHandlers</code>.<br><img src="/images/00020/02.png" alt="Figure 12.2 Server logic" title="Figure 12.2 Server logic"></p><h3 id="Handling-HTTP-requests"><a href="#Handling-HTTP-requests" class="headerlink" title="Handling HTTP requests"></a>Handling HTTP requests</h3><p>The following list shows the code for <code>HttpRequestHandler</code>, which extends <code>SimpleChannelInboundHandler</code> for <code>FullHttpRequest</code> messages. Notice how the implementation of <code>channelRead0()</code> forwards any requests for the URI <code>/ws</code>.</p><p>This represents the first part of the chat server, which manages pure HTTP requests and responses. Next we’ll handle the WebSocket frames, which transmit the actual chat messages. </p><blockquote><p><strong>WEBSOCKET FRAMES</strong><br>WebSockets transmit data in frames, each of which represents a part of a message. A complete message may consist of many frames. </p></blockquote><h3 id="Handling-WebSocket-frames"><a href="#Handling-WebSocket-frames" class="headerlink" title="Handling WebSocket frames"></a>Handling WebSocket frames</h3><p>The WebSocket RFC, published by the IETF, defines six frames; Netty provides a POJO implementation for each of them. The following table lists the frame types and describes their use.<br><img src="/images/00020/03.png" alt=""> </p><p>Our chat application will use the following frame types:</p><ul><li><code>CloseWebSocketFrame</code></li><li><code>PingWebSocketFrame</code></li><li><code>PongWebSocketFrame</code></li><li><code>TextWebSocketFrame</code></li></ul><p><code>TextWebSocketFrame</code> is the only one we actually need to handle. In conformity with the WebSocket RFC, Netty provides a <code>WebSocketServerProtocolHandler</code> to manage the others.</p><p>The following listing shows our <code>ChannelInboundHandler</code> for <code>TextWebSocketFrames</code>, which will also track all the active WebSocket connections in its ChannelGroup.<br><img src="/images/00020/04.png" alt=""></p><h3 id="Initializing-the-ChannelPipeline"><a href="#Initializing-the-ChannelPipeline" class="headerlink" title="Initializing the ChannelPipeline"></a>Initializing the ChannelPipeline</h3><p>The following listing shows the code for the resulting <code>ChatServerInitializer</code>.<br><img src="/images/00020/05.png" alt=""></p><p>The call to <code>initChannel()</code> sets up the <code>ChannelPipeline</code> of the newly registered <code>Channel</code> by installing all the required <code>ChannelHandlers</code>. These are summarized in the following table, along with their individual responsibilities.<br><img src="/images/00020/06.png" alt=""></p><p>The state of the pipeline before the upgrade is illustrated in figure 12.3.<br><img src="/images/00020/07.png" alt="Figure 12.3 ChannelPipeline before WebSocket upgrade" title="Figure 12.3 ChannelPipeline before WebSocket upgrade"></p><p>Figure 12.4 shows the <code>ChannelPipeline</code> after these operations have completed.<br><img src="/images/00020/08.png" alt="Figure 12.4 ChannelPipeline after WebSocket upgrade" title="Figure 12.4 ChannelPipeline after WebSocket upgrade"></p><h3 id="Bootstrapping"><a href="#Bootstrapping" class="headerlink" title="Bootstrapping"></a>Bootstrapping</h3><p>The final piece of the picture is the code that bootstraps the server and installs the <code>ChatServerInitializer</code>. This will be handled by the <code>ChatServer</code> class.</p><h2 id="Testing-the-application"><a href="#Testing-the-application" class="headerlink" title="Testing the application"></a>Testing the application</h2><p>We’ll use the following Maven command to build and start the server:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -PChatServer clean package exec:exec</span><br></pre></td></tr></table></figure></p><p>To use a different port, you can either edit the value in the file or override it with a System property:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -PChatServer -Dport=1111 clean package exec:exec</span><br></pre></td></tr></table></figure></p><p>Figure 12.5 shows the UI in the Chrome browser.<br><img src="/images/00020/09.png" alt="Figure 12.5 WebSocket ChatServer demonstration" title="Figure 12.5 WebSocket ChatServer demonstration"></p><p>The figure shows two connected clients. The first is connected using the interface at the top. The second client is connected via the Chrome browser’s command line at the bottom. You’ll notice that there are messages sent from both clients, and each message is displayed to both.</p><h3 id="What-about-encryption"><a href="#What-about-encryption" class="headerlink" title="What about encryption?"></a>What about encryption?</h3><p>The following listing shows how this can be done by extending our <code>ChatServerInitializer</code> to create a <code>SecureChatServerInitializer</code>.<br><img src="/images/00020/10.png" alt=""></p><p>The final step is to adapt the <code>ChatServer</code> to use the <code>SecureChatServerInitializer</code> so as to install the <code>SslHandler</code> in the pipeline. This gives us the <code>SecureChatServer</code> shown here.<br><img src="/images/00020/11.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h1&gt;&lt;p&gt;This chapter covers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The concept of a real-time web&lt;/li&gt;
&lt;li&gt;The WebSocket protocol&lt;/li&gt;
&lt;li&gt;Building a WebSocket-based chat room server with Netty&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://mindawei.github.io/categories/Netty/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty" scheme="http://mindawei.github.io/tags/Netty/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Netty-in-Action》笔记（11）</title>
    <link href="http://mindawei.github.io/2018/02/19/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89/"/>
    <id>http://mindawei.github.io/2018/02/19/《Netty-in-Action》笔记（11）/</id>
    <published>2018-02-19T06:31:52.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Provided-ChannelHandlers-and-codecs"><a href="#Provided-ChannelHandlers-and-codecs" class="headerlink" title="Provided ChannelHandlers and codecs"></a>Provided ChannelHandlers and codecs</h1><p>This chapter covers</p><ul><li>Securing Netty applications with SSL/TLS</li><li>Building Netty HTTP/HTTPS applications</li><li>Handling idle connections and timeouts</li><li>Decoding delimited and length-based protocols</li><li>Writing big data</li></ul><a id="more"></a><h2 id="Securing-Netty-applications-with-SSL-TLS"><a href="#Securing-Netty-applications-with-SSL-TLS" class="headerlink" title="Securing Netty applications with SSL/TLS"></a>Securing Netty applications with SSL/TLS</h2><p>To support SSL/TLS, Java provides the package <code>javax.net.ssl</code>, whose classes <code>SSLContext</code> and <code>SSLEngine</code> make it quite straightforward to implement decryption and encryption. Netty leverages this API by way of a <code>ChannelHandler</code> implementation named <code>SslHandler</code>, which employs an <code>SSLEngine</code> internally to do the actual work.</p><blockquote><p><strong>Netty’s OpenSSL/SSLEngine implementation</strong><br>Netty also provides an <code>SSLEngine</code> implementation that uses the OpenSSL toolkit(www.openssl.org). This class, <code>OpenSslEngine</code>, offers better performance than the <code>SSLEngine</code> implementation supplied by the JDK.</p><p>Netty applications (clients and servers) can be configured to use <code>OpenSslEngine</code> by default if the OpenSSL libraries are available. If not, Netty will fall back to the JDK implementation. For detailed instructions on configuring OpenSSL support, please see the Netty documentation at <code>http://netty.io/wiki/forked-tomcat-native.html#wikih2-1</code>.</p><p>Note that the SSL API and data flow are identical whether you use the JDK’s <code>SSLEngine</code> or Netty’s <code>OpenSslEngine</code>.</p></blockquote><p>Figure 11.1 shows data flow using <code>SslHandler</code>.<br><img src="/images/00019/01.png" alt="Figure 11.1 Data flow through SslHandler for decryption and encryption" title="Figure 11.1 Data flow through SslHandler for decryption and encryption"></p><p>Listing 11.1 shows how an <code>SslHandler</code> is added to a <code>ChannelPipeline</code> using a <code>ChannelInitializer</code>.<br><img src="/images/00019/02.png" alt=""> </p><p>The <code>SslHandler</code> has some useful methods, as shown in the following table.<br><img src="/images/00019/03.png" alt=""> </p><h2 id="Building-Netty-HTTP-HTTPS-applications"><a href="#Building-Netty-HTTP-HTTPS-applications" class="headerlink" title="Building Netty HTTP/HTTPS applications"></a>Building Netty HTTP/HTTPS applications</h2><h3 id="HTTP-decoder-encoder-and-codec"><a href="#HTTP-decoder-encoder-and-codec" class="headerlink" title="HTTP decoder, encoder, and codec"></a>HTTP decoder, encoder, and codec</h3><p>Figures 11.2 shows the methods for HTTP requests .<br><img src="/images/00019/04.png" alt="Figure 11.2 HTTP request component parts" title="Figure 11.2 HTTP request component parts"> </p><p>Figures 11.3 shows the methods for HTTP responses.<br><img src="/images/00019/05.png" alt="Figure 11.3 HTTP response component parts" title="Figure 11.3 HTTP response component parts"> </p><p>The following table gives an overview of the HTTP decoders and encoders that handle and produce these messages.<br><img src="/images/00019/06.png" alt=""> </p><p>All types of HTTP messages (<code>FullHttpRequest</code>, <code>LastHttpContent</code>, and those shown in the above list) implement the <code>HttpObject</code> interface.</p><p>The class <code>HttpPipelineInitializer</code> in the next listing shows how simple it is to add HTTP support to your application.<br><img src="/images/00019/07.png" alt=""> </p><h3 id="HTTP-message-aggregation"><a href="#HTTP-message-aggregation" class="headerlink" title="HTTP message aggregation"></a>HTTP message aggregation</h3><p>Netty provides an aggregator that merges message parts into <code>FullHttpRequest</code> and <code>FullHttpResponse</code> messages. This way you always see the full message contents. The following list shows how this is done.<br><img src="/images/00019/08.png" alt=""> </p><h3 id="HTTP-compression"><a href="#HTTP-compression" class="headerlink" title="HTTP compression"></a>HTTP compression</h3><p>Netty provides <code>ChannelHandler</code> implementations for compression and decompression that support both <code>gzip</code> and <code>deflate</code> encodings.</p><blockquote><p><strong>HTTP request header</strong><br>The client can indicate supported encryption modes by supplying the followingheader:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /encrypted-area HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p><p>Note, however, that the server isn’t obliged to compress the data it sends.</p></blockquote><p>An example is shown in the following listing.<br><img src="/images/00019/09.png" alt=""> </p><blockquote><p><strong>Compression and dependencies</strong><br>If you’re using JDK 6 or earlier, you’ll need to add JZlib (www.jcraft.com/jzlib/) to the CLASSPATH to support compression. For Maven, add the following dependency:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.jcraft&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jzlib&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Using-HTTPS"><a href="#Using-HTTPS" class="headerlink" title="Using HTTPS"></a>Using HTTPS</h3><p>The following listing shows that enabling HTTPS is only a matter of adding an <code>SslHandler</code> to the mix.<br><img src="/images/00019/10.png" alt=""> </p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSockets provide a true <em>bidirectional</em> exchange of data between client and server.</p><p>Figure 11.4 gives a general idea of the WebSocket protocol.  In this scenario the communication starts as plain HTTP and upgrades to bidirectional WebSocket.<br><img src="/images/00019/11.png" alt="Figure 11.4 WebSocket protocol" title="Figure 11.4 WebSocket protocol"></p><p>As shown in the following table, <code>WebSocketFrames</code> can be classed as data or control frames.<br><img src="/images/00019/12.png" alt=""> </p><blockquote><p><strong>Secure WebSocket</strong><br>To add security to WebSocket, simply insert the <code>SslHandler</code> as the first <code>ChannelHandler</code> in the pipeline.</p></blockquote><h2 id="Idle-connections-and-timeouts"><a href="#Idle-connections-and-timeouts" class="headerlink" title="Idle connections and timeouts"></a>Idle connections and timeouts</h2><p>Detecting idle connections and timeouts is essential to freeing resources in a timely manner. This is such a common task that Netty provides several <code>ChannelHandler</code> implementations just for this purpose. The following table shows these.<br><img src="/images/00019/13.png" alt=""> </p><p>Let’s take a closer look at <code>IdleStateHandler</code>, the one most used in practice. The following list shows this.<br><img src="/images/00019/14.png" alt=""> </p><h2 id="Decoding-delimited-and-length-based-protocols"><a href="#Decoding-delimited-and-length-based-protocols" class="headerlink" title="Decoding delimited and length-based protocols"></a>Decoding delimited and length-based protocols</h2><h3 id="Delimited-protocols"><a href="#Delimited-protocols" class="headerlink" title="Delimited protocols"></a>Delimited protocols</h3><p>The decoders listed in the following table will help you to define custom decoders that can extract frames delimited by any sequence of tokens.<br><img src="/images/00019/15.png" alt=""></p><p>Figure 11.5 shows how frames are handled when delimited by the end-of-line sequence <code>\r\n</code> (carriage return + line feed).<br><img src="/images/00019/16.png" alt="Figure 11.5 Frames delimited by line endings" title="Figure 11.5 Frames delimited by line endings"></p><p>The following listing shows how you can use LineBasedFrameDecoder to handle the case shown in figure 11.5.<br><img src="/images/00019/17.png" alt=""></p><h3 id="Length-based-protocols"><a href="#Length-based-protocols" class="headerlink" title="Length-based protocols"></a>Length-based protocols</h3><p>The following table lists the two decoders Netty provides for handling length-based protocols.<br><img src="/images/00019/18.png" alt=""></p><p>Figure 11.6 shows the operation of a <code>FixedLengthFrameDecoder</code> that has been constructed with a frame length of 8 bytes.<br><img src="/images/00019/19.png" alt="Figure 11.6 Decoding a frame length of 8 bytes" title="Figure 11.6 Decoding a frame length of 8 bytes"></p><p><code>LengthFieldBasedFrameDecoder</code> determines the frame length from the header field and extracts the specified number of bytes from the data stream.</p><p>Figure 11.7 shows an example where the length field in the header is at offset 0 and has a length of 2 bytes.<br><img src="/images/00019/20.png" alt="Figure 11.7 Message with variable frame size encoded in the header" title="Figure 11.7 Message with variable frame size encoded in the header"></p><p>The following list shows the use of a constructor whose three arguments are <code>maxFrameLength</code>, <code>lengthFieldOffset</code>, and <code>lengthFieldLength</code>.<br><img src="/images/00019/21.png" alt=""></p><h2 id="Writing-big-data"><a href="#Writing-big-data" class="headerlink" title="Writing big data"></a>Writing big data</h2><p>This listing shows how you can transmit a file’s contents using zero-copy by creating a <code>DefaultFileRegion</code> from a <code>FileInputStream</code> and writing it to a <code>Channel</code>.<br><img src="/images/00019/22.png" alt=""></p><p>This example applies only to the direct transmission of a file’s contents, excluding any processing of the data by the application. In cases where you need to copy the data from the file system into user memory, you can use <code>ChunkedWriteHandler</code>, which provides support for writing a large data stream asynchronously without incurring high memory consumption.</p><p>The key is interface <code>ChunkedInput&lt;B&gt;</code>, where the parameter <code>B</code> is the type returned by the method <code>readChunk()</code>. Four implementations of this interface are provided, as listed in the following table.<br><img src="/images/00019/23.png" alt=""></p><p>The following list illustrates the use of <code>ChunkedStream</code>, the implementation most often used in practice.<br><img src="/images/00019/24.png" alt=""></p><h2 id="Serializing-data"><a href="#Serializing-data" class="headerlink" title="Serializing data"></a>Serializing data</h2><h3 id="JDK-serialization"><a href="#JDK-serialization" class="headerlink" title="JDK serialization"></a>JDK serialization</h3><p>If your application has to interact with peers that use <code>ObjectOutputStream</code> and <code>ObjectInputStream</code>, and compatibility is your primary concern, then JDK serialization is the right choice. The following table lists the serialization classes that Netty provides for interoperating with the JDK.<br><img src="/images/00019/25.png" alt=""></p><h3 id="Serialization-with-JBoss-Marshalling"><a href="#Serialization-with-JBoss-Marshalling" class="headerlink" title="Serialization with JBoss Marshalling"></a>Serialization with JBoss Marshalling</h3><p>If you are free to make use of external dependencies, JBoss Marshalling is ideal: It’s up to three times faster than JDK Serialization and more compact. The overview on the JBoss Marshalling homepage defines it this way:</p><blockquote><p>JBoss Marshalling is an alternative serialization API that fixes many of the problems found in the JDK serialization API while remaining fully compatible with java.io.Serializable and its relatives, and adds several new tunable parameters and additional features, all of which are pluggable via factory configuration (externalizers, class/instance lookup tables, class resolution, and object replacement, to name a few).</p></blockquote><p>Netty supports JBoss Marshalling with the two decoder/encoder pairs shown in the following table.  The first set is compatible with peers that use only JDK Serialization. The second, which provides maximum performance, is for use with peers that use JBoss Marshalling.<br><img src="/images/00019/26.png" alt=""></p><p>The following listing shows how to use <code>MarshallingDecoder</code> and <code>MarshallingEncoder</code>.<br><img src="/images/00019/27.png" alt=""></p><h3 id="Serialization-via-Protocol-Buffers"><a href="#Serialization-via-Protocol-Buffers" class="headerlink" title="Serialization via Protocol Buffers"></a>Serialization via Protocol Buffers</h3><p>The following table shows the <code>ChannelHandler</code> implementations Netty supplies for protobuf support.<br><img src="/images/00019/28.png" alt=""></p><p>Here again, using protobuf is a matter of adding the right <code>ChannelHandler</code> to the <code>ChannelPipeline</code>, as shown in the following list.<br><img src="/images/00019/29.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Provided-ChannelHandlers-and-codecs&quot;&gt;&lt;a href=&quot;#Provided-ChannelHandlers-and-codecs&quot; class=&quot;headerlink&quot; title=&quot;Provided ChannelHandlers and codecs&quot;&gt;&lt;/a&gt;Provided ChannelHandlers and codecs&lt;/h1&gt;&lt;p&gt;This chapter covers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Securing Netty applications with SSL/TLS&lt;/li&gt;
&lt;li&gt;Building Netty HTTP/HTTPS applications&lt;/li&gt;
&lt;li&gt;Handling idle connections and timeouts&lt;/li&gt;
&lt;li&gt;Decoding delimited and length-based protocols&lt;/li&gt;
&lt;li&gt;Writing big data&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://mindawei.github.io/categories/Netty/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty" scheme="http://mindawei.github.io/tags/Netty/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Netty-in-Action》笔记（10）</title>
    <link href="http://mindawei.github.io/2018/02/18/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89/"/>
    <id>http://mindawei.github.io/2018/02/18/《Netty-in-Action》笔记（10）/</id>
    <published>2018-02-18T12:46:25.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-codec-framework"><a href="#The-codec-framework" class="headerlink" title="The codec framework"></a>The codec framework</h1><p>This chapter covers</p><ul><li>An overview of decoders, encoders and codecs</li><li>Netty’s codec classes</li></ul><a id="more"></a><h2 id="What-is-a-codec"><a href="#What-is-a-codec" class="headerlink" title="What is a codec?"></a>What is a codec?</h2><p>This conversion logic is handled by a <em>codec</em>, which consists of an encoder and a decoder, each of which transforms a stream of bytes from one format to another.</p><h2 id="Decoders"><a href="#Decoders" class="headerlink" title="Decoders"></a>Decoders</h2><p>These classes cover two distinct use cases:</p><ul><li>Decoding bytes to messages — <code>ByteToMessageDecoder</code> and <code>ReplayingDecoder</code></li><li>Decoding one message type to another — <code>MessageToMessageDecoder</code></li></ul><h3 id="Abstract-class-ByteToMessageDecoder"><a href="#Abstract-class-ByteToMessageDecoder" class="headerlink" title="Abstract class ByteToMessageDecoder"></a>Abstract class ByteToMessageDecoder</h3><p>The following table shows two most important methods in <code>ByteToMessageDecoder</code> API.<br><img src="/images/00018/01.png" alt=""></p><p>To decode the byte stream, you’ll extend <code>ByteToMessageDecoder</code>. The design is illustrated in figure 10.1.<br><img src="/images/00018/02.png" alt="Figure 10.1 ToIntegerDecoder" title="Figure 10.1 ToIntegerDecoder"></p><p>This listing shows the code for <code>ToIntegerDecoder</code>.<br><img src="/images/00018/03.png" alt=""></p><blockquote><p><strong>Reference counting in codecs</strong><br>once a message has been encoded or decoded, it will automatically be released by a call to <code>ReferenceCountUtil.release(message)</code>. If you need to keep a reference for later use you can call <code>ReferenceCountUtil.retain(message)</code>. This increments the reference count, preventing the message from being released.</p></blockquote><h3 id="Abstract-class-ReplayingDecoder"><a href="#Abstract-class-ReplayingDecoder" class="headerlink" title="Abstract class ReplayingDecoder"></a>Abstract class ReplayingDecoder</h3><p>The full declaration of this class is<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</span><br></pre></td></tr></table></figure></p><p>The parameter <code>S</code> specifies the type to be used for state management, where <code>Void</code> indicates that none is to be performed. The following listing shows a reimplementation of <code>ToIntegerDecoder</code> based on <code>ReplayingDecoder</code>.<br><img src="/images/00018/04.png" alt=""></p><p>Please take note of these aspects of <code>ReplayingDecoderBuffer</code>:</p><ul><li>Not all <code>ByteBuf</code> operations are supported. If an unsupported method is called, an <code>UnsupportedOperationException</code> will be thrown.</li><li><code>ReplayingDecoder</code> is slightly slower than <code>ByteToMessageDecoder</code></li></ul><p>Here’s a simple guideline: use <code>ByteToMessageDecoder</code> if it doesn’t introduce excessive complexity; otherwise, use <code>ReplayingDecoder</code>.</p><blockquote><p><strong>More decoders</strong><br>The following classes handle more complex use cases:</p><ul><li><code>io.netty.handler.codec.LineBasedFrameDecoder</code> — This class, used internally by Netty, uses end-of-line control characters (<code>\n</code> or <code>\r\n</code>) to parse the message data.</li><li><code>io.netty.handler.codec.http.HttpObjectDecoder</code> — A decoder for HTTP data.</li></ul></blockquote><h3 id="Abstract-class-MessageToMessageDecoder"><a href="#Abstract-class-MessageToMessageDecoder" class="headerlink" title="Abstract class MessageToMessageDecoder"></a>Abstract class MessageToMessageDecoder</h3><p>In this section we’ll explain how to convert between message formats using the abstract base class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MessageToMessageDecoder&lt;I&gt; </span><br><span class="line"> extends ChannelInboundHandlerAdapter</span><br></pre></td></tr></table></figure></p><p>The parameter <code>I</code> specifies the type of the input msg argument to <code>decode()</code>, which is the only method you have to implement. The following table shows the details of this method.<br><img src="/images/00018/05.png" alt=""></p><p>The design of <code>IntegerToStringDecoder</code> is illustrated in figure 10.2.<br><img src="/images/00018/06.png" alt="Figure 10.2 IntegerToStringDecoder" title="Figure 10.2 IntegerToStringDecoder"></p><p>The following listing is the implementation of <code>IntegerToStringDecoder</code>.<br><img src="/images/00018/07.png" alt=""></p><blockquote><p><strong>HttpObjectAggregator</strong><br>For a more complex example, please examine the class <code>io.netty.handler.codec.http.HttpObjectAggregator</code>, which extends <code>MessageToMessageDecoder&lt;HttpObject&gt;</code>.</p></blockquote><h3 id="Class-TooLongFrameException"><a href="#Class-TooLongFrameException" class="headerlink" title="Class TooLongFrameException"></a>Class TooLongFrameException</h3><p>Netty provides a <code>TooLongFrameException</code>, which is intended to be thrown by decoders if a frame exceeds a specified size limit.</p><p>Listing 10.4 shows how a <code>ByteToMessageDecoder</code> can make use of <code>TooLongFrameException</code> to notify other <code>ChannelHandlers</code> in the <code>ChannelPipeline</code> about the occurrence of a frame-size overrun.<br><img src="/images/00018/08.png" alt=""></p><h2 id="Encoders"><a href="#Encoders" class="headerlink" title="Encoders"></a>Encoders</h2><h3 id="Abstract-class-MessageToByteEncoder"><a href="#Abstract-class-MessageToByteEncoder" class="headerlink" title="Abstract class MessageToByteEncoder"></a>Abstract class MessageToByteEncoder</h3><p>The following table shows the <code>MessageToByteEncoder</code> API.<br><img src="/images/00018/09.png" alt=""></p><p>You may have noticed that this class has only one method, while decoders have two. The reason is that decoders often need to produce a last message after the <code>Channel</code> has closed (hence the <code>decodeLast()</code> method).</p><p>Figure 10.3 shows a <code>ShortToByteEncoder</code>.<br><img src="/images/00018/10.png" alt="Figure 10.3 ShortToByteEncoder" title="Figure 10.3 ShortToByteEncoder"></p><p>The implementation of <code>ShortToByteEncoder</code> is shown in the following listing.<br><img src="/images/00018/11.png" alt=""></p><p>Netty provides several specializations of <code>MessageToByteEncoder</code> upon which you can base your own implementations. The class <code>WebSocket08FrameEncoder</code> provides a good practical example. You’ll find it in the package <code>io.netty.handler.codec.http.websocketx</code>.</p><h3 id="Abstract-class-MessageToMessageEncoder"><a href="#Abstract-class-MessageToMessageEncoder" class="headerlink" title="Abstract class MessageToMessageEncoder"></a>Abstract class MessageToMessageEncoder</h3><p>The following table shows the <code>MessageToMessageEncoder</code> API.<br><img src="/images/00018/12.png" alt=""></p><p>Figure 10.4 shows a <code>IntegerToStringEncoder</code>.<br><img src="/images/00018/13.png" alt="Figure 10.4 IntegerToStringEncoder" title="Figure 10.4 IntegerToStringEncoder"></p><p>As shown in the next listing, the encoder adds a <code>String</code> representation of each outbound <code>Integer</code> to the <code>List</code>.<br><img src="/images/00018/14.png" alt=""></p><p>For an interesting specialized use of <code>MessageToMessageEncoder</code>, look at the class <code>io.netty.handler.codec.protobuf.ProtobufEncoder</code>, which handles data formats defined by Google’s Protocol Buffers specification.</p><h2 id="Abstract-codec-classes"><a href="#Abstract-codec-classes" class="headerlink" title="Abstract codec classes"></a>Abstract codec classes</h2><h3 id="Abstract-class-ByteToMessageCodec"><a href="#Abstract-class-ByteToMessageCodec" class="headerlink" title="Abstract class ByteToMessageCodec"></a>Abstract class ByteToMessageCodec</h3><p>The following table shows the <code>ByteToMessageCodec</code> API.<br><img src="/images/00018/15.png" alt=""></p><p>Any request/response protocol could be a good candidate for using the <code>ByteToMessageCodec</code>. </p><h3 id="Abstract-class-MessageToMessageCodec"><a href="#Abstract-class-MessageToMessageCodec" class="headerlink" title="Abstract class MessageToMessageCodec"></a>Abstract class MessageToMessageCodec</h3><p><code>MessageToMessageCodec</code> is a parameterized class, defined as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MessageToMessageCodec&lt;INBOUND_IN,OUTBOUND_IN&gt;</span><br></pre></td></tr></table></figure></p><p>The important methods are listed in the following table.<br><img src="/images/00018/16.png" alt=""></p><blockquote><p><strong>WebSocket protocol</strong><br><code>WebSocket</code> is a recent protocol that enables full bidirectional communications between web browsers and servers. </p></blockquote><h3 id="Class-CombinedChannelDuplexHandler"><a href="#Class-CombinedChannelDuplexHandler" class="headerlink" title="Class CombinedChannelDuplexHandler"></a>Class CombinedChannelDuplexHandler</h3><p><code>CombinedChannelDuplexHandler</code> declared as<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class CombinedChannelDuplexHandler</span><br><span class="line"> &lt;I extends ChannelInboundHandler, O extends ChannelOutboundHandler&gt;</span><br></pre></td></tr></table></figure></p><p>First, examine <code>ByteToCharDecoder</code> in the following listing.<br><img src="/images/00018/17.png" alt=""></p><p>The following list shows <code>CharToByteEncoder</code>, which converts <code>Characters</code> back to bytes.<br><img src="/images/00018/18.png" alt=""></p><p>Now that we have a decoder and encoder, we’ll combine them to build up a codec. This listing shows how this is done.<br><img src="/images/00018/19.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;The-codec-framework&quot;&gt;&lt;a href=&quot;#The-codec-framework&quot; class=&quot;headerlink&quot; title=&quot;The codec framework&quot;&gt;&lt;/a&gt;The codec framework&lt;/h1&gt;&lt;p&gt;This chapter covers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An overview of decoders, encoders and codecs&lt;/li&gt;
&lt;li&gt;Netty’s codec classes&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://mindawei.github.io/categories/Netty/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty" scheme="http://mindawei.github.io/tags/Netty/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《Netty-in-Action》笔记（9）</title>
    <link href="http://mindawei.github.io/2018/02/18/%E3%80%8ANetty-in-Action%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89/"/>
    <id>http://mindawei.github.io/2018/02/18/《Netty-in-Action》笔记（9）/</id>
    <published>2018-02-18T11:00:27.000Z</published>
    <updated>2018-05-06T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unit-testing"><a href="#Unit-testing" class="headerlink" title="Unit testing"></a>Unit testing</h1><p>This chapter covers</p><ul><li>Unit testing</li><li>Overview of <code>EmbeddedChannel</code></li><li>Testing <code>ChannelHandlers</code> with <code>EmbeddedChannel</code></li></ul><a id="more"></a><h2 id="Overview-of-EmbeddedChannel"><a href="#Overview-of-EmbeddedChannel" class="headerlink" title="Overview of EmbeddedChannel"></a>Overview of EmbeddedChannel</h2><p>Netty provides what it calls an <em>embedded transport</em> for testing <code>ChannelHandlers</code>. This transport is a feature of a special <code>Channel</code> implementation, <code>EmbeddedChannel</code>, which provides a simple way to pass events through the pipeline.</p><p>The relevant methods of EmbeddedChannel are listed in the following table.<br><img src="/images/00017/01.png" alt=""></p><p>Figure 9.1 shows how data flows through the <code>ChannelPipeline</code> using the methods of <code>EmbeddedChannel</code>.<br><img src="/images/00017/02.png" alt="Figure 9.1 EmbeddedChannel data flow" title="Figure 9.1 EmbeddedChannel data flow"></p><h2 id="Testing-ChannelHandlers-with-EmbeddedChannel"><a href="#Testing-ChannelHandlers-with-EmbeddedChannel" class="headerlink" title="Testing ChannelHandlers with EmbeddedChannel"></a>Testing ChannelHandlers with EmbeddedChannel</h2><h3 id="Testing-inbound-messages"><a href="#Testing-inbound-messages" class="headerlink" title="Testing inbound messages"></a>Testing inbound messages</h3><p>Figure 9.2 represents a simple <code>ByteToMessageDecoder</code> implementation.<br><img src="/images/00017/03.png" alt="Figure 9.2 Decoding via FixedLengthFrameDecoder" title="Figure 9.2 Decoding via FixedLengthFrameDecoder"></p><p>The implementation of the decoder is shown in the following listing.<br><img src="/images/00017/04.png" alt=""></p><p>This listing shows a test of the preceding code using <code>EmbeddedChannel</code>.<br><img src="/images/00017/11.png" alt=""></p><h3 id="Testing-outbound-messages"><a href="#Testing-outbound-messages" class="headerlink" title="Testing outbound messages"></a>Testing outbound messages</h3><p>Figure 9.3 shows the logic.<br><img src="/images/00017/05.png" alt=""></p><p>The next listing implements this logic, illustrated in figure 9.3.<br><img src="/images/00017/06.png" alt=""></p><p>The next listing tests the code using <code>EmbeddedChannel</code>.<br><img src="/images/00017/07.png" alt=""></p><h2 id="Testing-exception-handling"><a href="#Testing-exception-handling" class="headerlink" title="Testing exception handling"></a>Testing exception handling</h2><p>In figure 9.4 the maximum frame size has been set to 3 bytes. If the size of a frame exceeds that limit, its bytes are discarded and a <code>TooLongFrameException</code> is thrown.<br><img src="/images/00017/08.png" alt="Figure 9.4 Decoding via FrameChunkDecoder" title="Figure 9.4 Decoding via FrameChunkDecoder"></p><p>The implementation is shown in the following listing.<br><img src="/images/00017/09.png" alt=""></p><p>Again, we’ll test the code using <code>EmbeddedChannel</code>.<br><img src="/images/00017/10.png" alt=""></p><p>The <code>try/catch</code> block used here is a special feature of <code>EmbeddedChannel</code>. If one of the <code>write*</code> methods produces a checked <code>Exception</code>, it will be thrown wrapped in a <code>RuntimeException</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Unit-testing&quot;&gt;&lt;a href=&quot;#Unit-testing&quot; class=&quot;headerlink&quot; title=&quot;Unit testing&quot;&gt;&lt;/a&gt;Unit testing&lt;/h1&gt;&lt;p&gt;This chapter covers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unit testing&lt;/li&gt;
&lt;li&gt;Overview of &lt;code&gt;EmbeddedChannel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Testing &lt;code&gt;ChannelHandlers&lt;/code&gt; with &lt;code&gt;EmbeddedChannel&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://mindawei.github.io/categories/Netty/"/>
    
    
      <category term="笔记" scheme="http://mindawei.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Netty" scheme="http://mindawei.github.io/tags/Netty/"/>
    
      <category term="Java" scheme="http://mindawei.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
